<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Computer Use Agent</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        :root {
            --primary-color: #2c3e50;
            --secondary-color: #3498db;
            --success-color: #27ae60;
            --warning-color: #f39c12;
            --danger-color: #e74c3c;
        }

        body {
            background-color: #f8f9fa;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            padding-top: 20px;
        }

        .header-title {
            color: var(--primary-color);
            text-align: center;
            font-weight: 600;
            margin-bottom: 1.5rem;
            padding-top: 0.5rem;
        }

        .quick-cmd-btn{
            display:inline-block;          /* åƒæŒ‰é’®ä¸€æ ·æ’åˆ— */
            padding:6px 12px;              /* å†…è¾¹è· */
            margin:4px;                    /* æŒ‰é’®ä¹‹é—´çš„é—´è· */
            background:#f5f5f5;            /* ç°è‰²åº•è‰² */
            border:1px solid #d0d0d0;      /* ç»†ç°è‰²è¾¹æ¡† */
            border-radius:6px;             /* åœ†è§’ */
            cursor:pointer;
            user-select:none;
            transition:background-color .15s,border-color .15s;
        }
        .quick-cmd-btn:hover{
            background:#e9ecef;            /* æ‚¬åœæ—¶ç¨å¾®å˜æ·± */
            border-color:#bcbcbc;
        }

.card {
            border-radius: 10px;
            box-shadow: 0 0.125rem 0.25rem rgba(0, 0, 0, 0.075);
            border: 1px solid rgba(0, 0, 0, 0.125);
        }

        .card-header {
            background-color: white;
            border-bottom: 1px solid rgba(0, 0, 0, 0.125);
            font-weight: 600;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .card-header:hover {
            background-color: #f8f9fa;
        }

        .toggle-icon {
            transition: transform 0.3s ease;
        }

        .toggle-icon.collapsed {
            transform: rotate(180deg);
        }

        .card-body {
            transition: all 0.3s ease;
        }

        .card-body.collapsed {
            display: none;
        }

        .preview-container {
            height: 560px;
            border-radius: 10px;
            border: 1px solid #e9ecef;
            background-color: #f8f9fa;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
        }

        .chat-container {
            height: 500px;
            overflow-y: auto;
            padding: 15px;
            background-color: #fff;
            border-radius: 10px;
            border: 1px solid #e9ecef;
        }

        .planner-container {
            max-height: 220px;
            overflow-y: auto;
        }

        .planner-item {
            padding: 8px 10px;
            border-left: 4px solid var(--secondary-color);
            background-color: #f1f8ff;
            border-radius: 6px;
            margin-bottom: 10px;
        }

        .planner-item:last-child {
            margin-bottom: 0;
        }

        .planner-item-title {
            font-weight: 600;
            color: var(--primary-color);
            display: flex;
            align-items: center;
            gap: 6px;
            margin-bottom: 4px;
        }

        .planner-item-description {
            color: #555;
            line-height: 1.4;
            font-size: 14px;
        }

        .planner-empty {
            color: #6c757d;
            text-align: center;
            padding: 16px 0;
        }

        .message {
            margin-bottom: 15px;
            padding: 10px 15px;
            border-radius: 10px;
            max-width: 80%;
        }

        .user-message {
            background-color: #3498db;
            color: white;
            margin-left: auto;
        }

        .assistant-message {
            background-color: #f1f1f1;
            color: #333;
        }

        .status-message {
            background-color: #e8f4fc;
            border-left: 4px solid #3498db;
        }

        .input-group {
            margin-top: 15px;
        }

        .countdown-container {
            position: fixed;
            top: 20px;
            right: 20px;
            background-color: var(--danger-color);
            color: white;
            padding: 10px 15px;
            border-radius: 8px;
            font-weight: bold;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            z-index: 9999;
        }

        .queue-info {
            background-color: #fff8e1;
            border-left: 4px solid var(--warning-color);
            padding: 10px;
            margin-bottom: 15px;
            border-radius: 4px;
        }

        .step-message {
            border-left: 4px solid #9b59b6;
            background-color: #f5f0fa;
        }

        .iframe-container {
            width: 100%;
            height: 560px;
            border-radius: 10px;
            overflow: hidden;
        }

        .iframe-container iframe {
            width: 100%;
            height: 100%;
            border: none;
        }

        .screenshot-container {
            text-align: center;
            border-radius: 10px;
            border: 1px solid #e9ecef;
            overflow-y: auto;
            max-height: 560px;
        }

        /* å…¨å±æ—¶è®© iframe å®¹å™¨å æ»¡è§†å£ */
        .iframe-container:fullscreen {
            width: 100vw;
            height: 100vh;
            border-radius: 0;
        }

        .screenshot-container img {
            max-width: 100%;
            height: auto;
            max-height: 500px;
            object-fit: contain;
        }

        .loading-spinner {
            display: inline-block;
            width: 1rem;
            height: 1rem;
            vertical-align: text-bottom;
            border: 0.2em solid currentColor;
            border-right-color: transparent;
            border-radius: 50%;
            animation: spinner-border 0.75s linear infinite;
        }

        @keyframes spinner-border {
            to {
                transform: rotate(360deg);
            }
        }

        .btn-primary {
            background-color: var(--secondary-color);
            border-color: var(--secondary-color);
        }

        .btn-primary:hover {
            background-color: #2980b9;
            border-color: #2980b9;
        }

        .btn-success {
            background-color: var(--success-color);
            border-color: var(--success-color);
        }

        .btn-warning {
            background-color: var(--warning-color);
            border-color: var(--warning-color);
        }

        .btn-danger {
            background-color: var(--danger-color);
            border-color: var(--danger-color);
        }

        .btn-disabled {
            pointer-events: none;
            opacity: 0.6;
        }

        .error-message {
            background-color: #f8d7da;
            border-color: #f5c6cb;
            color: #721c24;
            padding: 0.75rem 1.25rem;
            border: 1px solid transparent;
            border-radius: 0.25rem;
            margin-bottom: 1rem;
        }

        /* ç¦ç”¨è®¾å¤‡é€‰æ‹©çš„æ ·å¼ */
        .device-select-disabled {
            pointer-events: none;
            background-color: #e9ecef;
            opacity: 0.7;
        }

        /* æ¨ç†çŠ¶æ€æ ·å¼ */
        .analyzing-spinner {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 6px;
            border-left: 4px solid #3498db;
            margin: 5px 0;
            font-style: italic;
            color: #666;
        }

        .analyzing-spinner .loading-spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid #3498db;
            border-right-color: transparent;
            border-radius: 50%;
            animation: spinner-border 0.75s linear infinite;
        }

        /* åˆ†æé˜¶æ®µæ ·å¼ */
        .analysis-stages-container {
            background-color: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
        }

        .analysis-stages-title {
            font-size: 16px;
            margin-bottom: 15px;
            color: #2c3e50;
            border-bottom: 1px solid #e9ecef;
            padding-bottom: 8px;
        }

        .analysis-stages-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .analysis-stage {
            display: flex;
            align-items: center;
            padding: 8px 12px;
            border-radius: 6px;
            transition: all 0.3s ease;
        }

        .analysis-stage.waiting {
            background-color: #ffffff;
            border: 1px solid #e9ecef;
            color: #6c757d;
        }

        .analysis-stage.active {
            background-color: #e3f2fd;
            border: 1px solid #2196f3;
            color: #1976d2;
            animation: pulse 1.5s infinite;
        }

        .analysis-stage.completed {
            background-color: #e8f5e8;
            border: 1px solid #4caf50;
            color: #2e7d32;
        }

        .stage-icon {
            font-size: 16px;
            margin-right: 8px;
            min-width: 20px;
        }

        .stage-name {
            font-weight: 500;
            min-width: 80px;
        }

        .stage-content {
            margin-left: 28px;
            font-size: 14px;
            color: #666;
            margin-top: 4px;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.02); }
            100% { transform: scale(1); }
        }

        /* åˆ†æDoneçŠ¶æ€æ ·å¼ */
        .completed-analysis {
            background-color: #e8f5e8 !important;
            border: 1px solid #4caf50 !important;
        }

        .analysis-completed-message {
            color: #2e7d32;
            font-size: 14px;
            text-align: center;
            padding: 8px;
        }
    </style>
</head>
<body>
    <div class="container-fluid">
        <h1 class="header-title"><img src="logo.png" alt="Logo" style="height: 1.4em; margin-right: 0.5rem;"> Mobile Agent v3</h1>

        <!-- å€’è®¡æ—¶æ˜¾ç¤º -->
        <div id="countdownContainer" class="countdown-container" style="display: none;">
            <span id="countdownText">â³ Remaining: 60:00</span>
        </div>

        <!-- é”™è¯¯æç¤ºåŒºåŸŸ -->
        <div id="errorMessageContainer" class="error-message" style="display: none;">
            <i class="fas fa-exclamation-triangle"></i> <span id="errorMessageText"></span>
        </div>

        <!-- TokenéªŒè¯çŠ¶æ€åŒºåŸŸ -->
        <div id="tokenValidationContainer" class="alert alert-info" style="display: none; margin-bottom: 1rem;">
            <div class="d-flex align-items-center">
                <div class="loading-spinner me-2"></div>
                <span>Verifying identity, please wait...</span>
            </div>
        </div>

        <!-- é…ç½®åŒºåŸŸ -->
        <div class="card mb-4">
            <div class="card-header" id="configCardHeader">
                <span><i class="fas fa-cog"></i> Task Settings</span>
                <i class="fas fa-chevron-down toggle-icon" id="configToggleIcon"></i>
            </div>
            <div class="card-body" id="configCardBody">
                <div class="row">
                    <div class="col-md-6">
                        <div class="mb-3">
                            <label class="form-label">Device</label>
                            <select class="form-select" id="deviceSelect">
                                <option value="e2b_desktop" selected>E2B Desktop</option>
                                <option value="pc_wuyin">Wuying PC</option>
                                <option value="phone_wuyin">Wuying Phone</option>
                            </select>
                        </div>

                        <div class="mb-3" style="display: none;">
                            <label class="form-label">Deep Thinking</label>
                            <select class="form-select" id="deepThinkingSelect">
                                <option value="false" selected>No</option>
                                <option value="true">Yes</option>
                            </select>
                        </div>

                        <div id="queueInfoContainer" class="queue-info" style="display: none;">
                            <i class="fas fa-list"></i> In queue... Position: <span id="queuePosition">0</span>/<span id="totalWaiting">0</span>
                        </div>
                    </div>

                    <div class="col-md-6">
                        <div class="mb-3">
                            <label class="form-label">Max Steps</label>
                            <input type="number" class="form-control" id="maxStepsInput" min="1" max="100" value="10">
                        </div>

                        <div class="mb-3">
                            <label class="form-label">Additional Info</label>
                            <input type="text" class="form-control" id="addonInfoInput" placeholder="Enter additional info for the PC_USE model">
                        </div>
                    </div>
                </div>

                <!-- æ–°å¢çš„é…ç½®é¡¹ -->
                <div class="row">
                    <div class="col-md-6">
                        <div class="mb-3" style="display: none;">
                            <label class="form-label">Pipeline Mode</label>
                            <select class="form-select" id="pipelineTypeSelect">
                                <option value="e2e">Direct Model</option>
                                <option value="agent" selected>Agent Framework</option>
                            </select>
                        </div>
                    </div>
                    <div class="col-md-6">
                        <div class="mb-3" style="display: none;">
                            <label class="form-label">Model Name</label>
                            <input type="text"
                                   class="form-control"
                                   id="modelNameInput"
                                   value="qwen"
                                   placeholder="Enter model name">
                        </div>
                    </div>
                </div>

                <div class="row">
                    <div class="col-md-6">
                        <div class="mb-3" style="display: none;">
                            <label class="form-label">Agent Framework Name</label>
                            <input type="text" class="form-control" id="agentFrameworkInput" placeholder="Enter agent framework name" disabled>
                        </div>
                    </div>
                    <div class="col-md-6">
                        <div class="mb-3" style="display: none;">
                            <label class="form-label">Extra Parameters</label>
                            <input type="text" class="form-control" id="extraParamsInput" placeholder="Enter extra parameters">
                        </div>
                    </div>
                </div>

                <div class="d-flex gap-2">
                    <button id="activateBtn" class="btn btn-success">
                        <i class="fas fa-bolt"></i> Activate Environment
                    </button>
                </div>
            </div>
        </div>

        <div class="row">
            <!-- Left chat panel -->
            <div class="col-md-6">
                <div class="card mb-4" id="plannerCard">
                    <div class="card-header">
                        <i class="fas fa-route"></i> Planner
                    </div>
                    <div class="card-body">
                        <div class="planner-container" id="plannerContainer">
                            <div class="planner-empty" id="plannerEmptyState">
                                <i class="fas fa-lightbulb"></i> Planner output will appear here
                            </div>
                        </div>
                    </div>
                </div>
                <div class="card">
                    <div class="card-header">
                        <i class="fas fa-comments"></i> Conversation
                    </div>
                    <div class="card-body">
                        <div class="chat-container" id="chatContainer">
                            <div class="text-center text-muted py-5" id="welcomeMessage">
                                <i class="fas fa-hand-wave fa-2x mb-3"></i>
                                <h5>Welcome to the Computer Use Agent!</h5>
                                <p class="mb-0">Enter the task you want to run below.</p>
                                <p class="mb-0">Example: use the web browser to get the current weather in Hangzhou via Bing Search</p>
                            </div>
                        </div>

                        <div class="input-group">
                            <input type="text" class="form-control" id="taskInput" placeholder="Enter the task to execute..." disabled>
                            <button class="btn btn-primary" type="button" id="sendBtn" disabled>
                                <i class="fas fa-paper-plane"></i> Send
                            </button>
                            <button id="stopTaskBtn" class="btn btn-danger" style="display: none;">
                                <i class="fas fa-stop"></i> Stop
                            </button>
                            <button class="btn btn-secondary" type="button" id="clearBtn">
                                <i class="fas fa-trash"></i> Clear
                            </button>
                        </div>
                        <!-- Quick command container -->
                        <div id="quickCmdContainer" class="mt-2 d-flex flex-wrap gap-2"></div>
                    </div>
                </div>
            </div>

            <!-- Right preview panel -->
            <div class="col-md-6">
                <div class="card">
                    <div class="card-header d-flex justify-content-between align-items-center">
                        <div><img src="wy_logo.png" alt="Logo" style="height: 1em; margin-right: 0.5rem;"> </div>
                        <div class="d-flex align-items-center gap-2">
                            <span id="previewScaleHint" class="text-muted" style="font-size: 0.9rem;"></span>
                            <button id="fullscreenToggleBtn" class="btn btn-sm btn-outline-secondary" title="Fullscreen preview">
                                <i class="fas fa-expand"></i>
                            </button>
                        </div>
                    </div>
                    <div class="card-body p-0">
                        <div class="preview-container" id="previewContainer">
                            <div class="text-center text-muted">
                                <i class="fas fa-desktop fa-3x mb-3"></i>
                                <h5>Waiting for the sandbox to start</h5>
                                <p class="mb-0">Enter a task on the left to start the Computer Use Agent</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        // å…¨å±€å¯¹è¯çŠ¶æ€ç®¡ç†å™¨
        class UserStateManager {
            constructor() {
                this.users = {}; // å­˜å‚¨æ‰€æœ‰å¯¹è¯çš„çŠ¶æ€
                this.currentUser = null; // å½“å‰æ´»è·ƒå¯¹è¯
            }

            // è®¾ç½®å½“å‰å¯¹è¯
            setCurrentUser(chatId) {
                this.currentUser = chatId;
                if (!this.users[chatId]) {
                    this.initializeUserState(chatId);
                }
                // åŠ è½½è¯¥å¯¹è¯çš„e2eé…ç½®
                setTimeout(loadE2eConfigFromUserState, 0);
                setTimeout(renderPlanner, 0);
            }

            // åˆå§‹åŒ–å¯¹è¯çŠ¶æ€
            initializeUserState(chatId) {
                this.users[chatId] = {
                    taskId: null,
                    sse: null,
                    isActivated: false,
                    isTaskRunning: false,
                    isQueued: false,
                    isSwitching: false,
                    currentSandboxType: 'e2b_desktop',
                    preferredPcSandboxType: 'e2b_desktop',
                    messages: [],
                    countdownStartTime: null,
                    countdownRemaining: 0,
                    processedMessages: new Set(),
                    pollInterval: null,
                    queueMonitorInterval: null,  // ğŸ”§ æ–°å¢ï¼šæ’é˜Ÿç›‘æ§å®šæ—¶å™¨
                    queueInfo: null,             // ğŸ”§ æ–°å¢ï¼šæ’é˜Ÿä¿¡æ¯
                    targetSandboxTypeForQueue: null,
                    // æ·»åŠ e2eé…ç½®
                    e2eConfig: {
                        pipelineType: 'agent',
                        modelName: '',
                        agentFramework: '',
                        extraParams: '',
                        deepThink: false,
                    },
                    // æ–°å¢ç­‰å¾…å€’è®¡æ—¶ç›¸å…³å±æ€§
                    waitingCountdown: false,
                    waitingCountdownInterval: null,
                    // ğŸ”§ æ–°å¢ï¼šè·Ÿè¸ªæ¿€æ´»è¿‡ç¨‹çŠ¶æ€
                    isActivating: false,
                    all_subtasks_complete_handled: false,
                    // Planner ä¿¡æ¯
                    planner: getDefaultPlannerState()
                };
            }

            // è·å–å½“å‰å¯¹è¯çŠ¶æ€
            getCurrentUserState() {
                if (!this.currentUser) return null;
                return this.users[this.currentUser] || null;
            }

            // è·å–æŒ‡å®šå¯¹è¯çŠ¶æ€
            getUserState(chatId) {
                return this.users[chatId] || null;
            }

            // æ›´æ–°å½“å‰å¯¹è¯çŠ¶æ€
            updateCurrentUserState(updates) {
                if (!this.currentUser) return;
                if (!this.users[this.currentUser]) {
                    this.initializeUserState(this.currentUser);
                }
                Object.assign(this.users[this.currentUser], updates);
            }

            // æ›´æ–°æŒ‡å®šå¯¹è¯çŠ¶æ€
            updateUserState(chatId, updates) {
                if (!this.users[chatId]) {
                    this.initializeUserState(chatId);
                }
                Object.assign(this.users[chatId], updates);
            }
        }

        // åˆ›å»ºå…¨å±€å¯¹è¯çŠ¶æ€ç®¡ç†å™¨å®ä¾‹
        const userStateManager = new UserStateManager();

        // è·å–å½“å‰å¯¹è¯çŠ¶æ€çš„ä¾¿æ·å‡½æ•°
        function getCurrentUserState() {
            return userStateManager.getCurrentUserState();
        }

        // æ›´æ–°å½“å‰å¯¹è¯çŠ¶æ€çš„ä¾¿æ·å‡½æ•°
        function updateCurrentUserState(updates) {
            userStateManager.updateCurrentUserState(updates);
            renderPlanner();
        }

        // Planner å·¥å…·å‡½æ•°
        function getDefaultPlannerState() {
            return {
                steps: [],
                updatedAt: null
            };
        }

        function escapeHtml(str) {
            if (typeof str !== 'string') {
                str = str !== undefined && str !== null ? String(str) : '';
            }
            return str
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#39;');
        }

        function renderPlanner() {
            const container = document.getElementById('plannerContainer');
            if (!container) {
                return;
            }

            const currentUserState = getCurrentUserState();
            const plannerState = currentUserState && currentUserState.planner
                ? currentUserState.planner
                : getDefaultPlannerState();

            const steps = Array.isArray(plannerState.steps) ? plannerState.steps : [];

            if (!steps.length) {
                container.innerHTML = `
                    <div class="planner-empty" id="plannerEmptyState">
                        <i class="fas fa-lightbulb"></i> Planner output will appear here
                    </div>
                `;
                return;
            }

            const itemsHtml = steps.map((step, index) => {
                const rawTitle = step.title ? escapeHtml(step.title) : '';
                const description = step.description ? escapeHtml(step.description) : '';
                const stepLabel = `Step ${index + 1}`;
                const title = rawTitle ? `${stepLabel} Â· ${rawTitle}` : stepLabel;
                const descriptionHtml = description
                    ? `<div class="planner-item-description">${description}</div>`
                    : '';
                return `
                    <div class="planner-item">
                        <div class="planner-item-title">
                            <span>ğŸ§­</span>
                            <span>${title}</span>
                        </div>
                        ${descriptionHtml}
                    </div>
                `;
            }).join('');

            container.innerHTML = itemsHtml;
        }

        function setPlannerSteps(steps) {
            const normalizedSteps = Array.isArray(steps) ? steps : [];
            updateCurrentUserState({
                planner: {
                    steps: normalizedSteps,
                    updatedAt: Date.now()
                }
            });
        }

        function clearPlanner() {
            updateCurrentUserState({
                planner: getDefaultPlannerState()
            });
        }

        function parsePlannerSteps(rawSteps) {
            if (!rawSteps) return [];

            const stepsArray = [];

            const addStep = (title, description) => {
                stepsArray.push({
                    title: title || '',
                    description: description || ''
                });
            };

            const normalizeObject = (item, index) => {
                if (!item || typeof item !== 'object') {
                    return;
                }

                let title = item.title || item.name || item.heading || item.step || item.action || '';
                let descriptionValue = item.description || item.detail || item.explanation || item.content || item.reason || '';

                if (title && typeof title !== 'string') {
                    title = JSON.stringify(title);
                }

                if (descriptionValue && typeof descriptionValue !== 'string') {
                    try {
                        descriptionValue = JSON.stringify(descriptionValue, null, 2);
                    } catch (e) {
                        descriptionValue = String(descriptionValue);
                    }
                }
                const description = descriptionValue || '';

                if (title || description) {
                    addStep(title || `Step ${index + 1}`, description);
                }
            };

            const handleSingleValue = (value, index) => {
                if (typeof value === 'string') {
                    if (!value.trim()) return;
                    addStep(`Step ${index + 1}`, value.trim());
                } else if (typeof value === 'number' || typeof value === 'boolean') {
                    addStep(`Step ${index + 1}`, String(value));
                } else if (typeof value === 'object') {
                    normalizeObject(value, index);
                }
            };

            if (typeof rawSteps === 'string') {
                try {
                    const parsed = JSON.parse(rawSteps);
                    return parsePlannerSteps(parsed);
                } catch (e) {
                    const lines = rawSteps.split(/\r?\n/).map(line => line.trim()).filter(Boolean);
                    lines.forEach((line, index) => handleSingleValue(line, index));
                    return stepsArray;
                }
            }

            if (Array.isArray(rawSteps)) {
                rawSteps.forEach((item, index) => handleSingleValue(item, index));
                return stepsArray;
            }

            if (typeof rawSteps === 'object') {
                const candidateKeys = ['steps', 'plan', 'plans', 'items', 'content', 'result'];
                for (const key of candidateKeys) {
                    if (Array.isArray(rawSteps[key])) {
                        return parsePlannerSteps(rawSteps[key]);
                    }
                }

                const stringCandidateKeys = ['text', 'message', 'result', 'plan_text'];
                for (const key of stringCandidateKeys) {
                    if (typeof rawSteps[key] === 'string') {
                        const parsed = parsePlannerSteps(rawSteps[key]);
                        if (parsed.length) {
                            return parsed;
                        }
                    }
                }

            }

            return stepsArray;
        }

        function handlePlannerContent(contentData) {
            if (!contentData) {
                return;
            }

            let stepsSource = contentData;

            if (contentData.steps || contentData.plan || contentData.plans || contentData.items) {
                stepsSource = contentData.steps || contentData.plan || contentData.plans || contentData.items;
            } else if (Array.isArray(contentData.content)) {
                stepsSource = contentData.content;
            }

            let steps = parsePlannerSteps(stepsSource);

            if (!steps.length && typeof contentData.text === 'string') {
                steps = parsePlannerSteps(contentData.text);
            }

            if (!steps.length && typeof contentData.message === 'string') {
                steps = parsePlannerSteps(contentData.message);
            }

            if (!steps.length && typeof contentData.result !== 'undefined') {
                steps = parsePlannerSteps(contentData.result);
            }

            if (!steps.length && typeof contentData.plan_text === 'string') {
                steps = parsePlannerSteps(contentData.plan_text);
            }

            if (steps.length) {
                setPlannerSteps(steps);
            }
        }

        // æš´éœ²ç»™å¤–éƒ¨è°ƒè¯•ä½¿ç”¨
        window.setPlannerSteps = setPlannerSteps;
        window.clearPlanner = clearPlanner;
        window.renderPlanner = renderPlanner;

        function isPhoneSandboxType(value) {
            return typeof value === 'string' && value.includes('phone');
        }

        function isPcSandboxType(value) {
            return typeof value === 'string' && !isPhoneSandboxType(value);
        }

        function updateSandboxTypeState(sandboxType) {
            const updates = { currentSandboxType: sandboxType };
            if (isPcSandboxType(sandboxType)) {
                updates.preferredPcSandboxType = sandboxType;
            }
            updateCurrentUserState(updates);
        }

        function getPreferredPcSandboxType() {
            const state = getCurrentUserState();
            if (state && state.preferredPcSandboxType) {
                return state.preferredPcSandboxType;
            }
            return 'e2b_desktop';
        }

        // å…¶ä»–å…¨å±€å˜é‡ï¼ˆä¸ä¾èµ–å¯¹è¯çŠ¶æ€ï¼‰
        let heartbeatInterval = null;
        let countdownInterval = null;
        let userId = 'user_a'; // é»˜è®¤ç”¨æˆ·ID
        let chatId = 'chat_a'; // é»˜è®¤å¯¹è¯ID
        let isTokenValidated = false; // TokenéªŒè¯çŠ¶æ€
        let tempUserId = null; // ä¸´æ—¶ç”¨æˆ·IDï¼Œé¿å…éªŒè¯æœŸé—´å†²çª

        // ä»URLå‚æ•°è·å–userIdå’ŒchatId
        function getUserAndChatIdFromUrl() {
            // è·å–å½“å‰ä¸»æœºåå¹¶å­˜å‚¨åˆ°å˜é‡ä¸­
            const hostname = window.location.hostname;
            console.log("Current hostname:", hostname);
            console.log("Current full URL:", window.location.href);

            // åˆ¤æ–­æ˜¯å¦ä¸ºæœ¬åœ°ç¯å¢ƒï¼ˆå¯ä»¥æ ¹æ®å®é™…éœ€æ±‚è°ƒæ•´åˆ¤æ–­æ¡ä»¶ï¼‰
            const isLocal = hostname === 'localhost' ||
                           hostname === '127.0.0.1' ||
                           hostname === '' ||
                           hostname.startsWith('local');

            if (isLocal) {
                // æœ¬åœ°ç¯å¢ƒç›´æ¥è¿”å›æœ¬åœ°ç”¨æˆ·å’Œå¯¹è¯ID
                console.log("Detected local environment, using local user and chat IDs.");
                isTokenValidated = true; // æœ¬åœ°ç¯å¢ƒç›´æ¥æ ‡è®°ä¸ºå·²éªŒè¯
                return { userId: 'local_user', chatId: 'local_chat' };
            } else {
                // è¿œç¨‹ç¯å¢ƒä¿æŒåŸæœ‰é€»è¾‘
                console.log("Detected remote environment, using remote authentication.");
                const urlParams = new URLSearchParams(window.location.search);
                const studioToken = urlParams.get('studio_token');
                if (studioToken) {
                    // ç”Ÿæˆä¸´æ—¶å”¯ä¸€ç”¨æˆ·IDï¼Œé¿å…éªŒè¯æœŸé—´å†²çª
                    tempUserId = 'temp_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                    // è°ƒç”¨åç«¯APIéªŒè¯tokenå¹¶è·å–userIdï¼ŒchatIdéšæœºç”Ÿæˆ
                    const chatId = 'chat_' + Math.random().toString(36).substr(2, 9);
                    validateStudioToken(studioToken, chatId);
                    return { userId: tempUserId, chatId: chatId }; // å…ˆè¿”å›ä¸´æ—¶å€¼ï¼Œåç»­å¼‚æ­¥æ›´æ–°userId
                }
                // å¦‚æœæ²¡æœ‰æä¾›studio_tokenï¼Œè¿”å›nullè¡¨ç¤ºæœªç™»å½•
                return null;
            }
        }

        // éªŒè¯studio tokenå¹¶è·å–userId
        async function validateStudioToken(studioToken, generatedChatId) {
            showTokenValidationUI(true); // æ˜¾ç¤ºéªŒè¯ä¸­UI

            try {
                // ä½¿ç”¨åç«¯ä»£ç†é¿å… CORS é—®é¢˜
                const response = await fetch(
                    `${getBackendUrl()}/cua/proxy/validate-studio-token?studio_token=${studioToken}`
                );

                if (response.status === 200) {
                    const data = await response.json();
                    if (data.Success && data.Data && data.Data.Uuid) {
                        userId = data.Data.Uuid; // æ›´æ–°userId
                        chatId = generatedChatId; // ä½¿ç”¨ç”Ÿæˆçš„chatId
                        isTokenValidated = true; // æ ‡è®°TokenéªŒè¯Done
                        userStateManager.setCurrentUser(chatId);
                        console.log(`User verified: userId=${userId}, chatId=${chatId}`);

                        showTokenValidationUI(false); // éšè—éªŒè¯ä¸­UI
                        enableUserOperations(); // å¯ç”¨ç”¨æˆ·æ“ä½œ

                        return { userId, chatId };
                    } else {
                        showErrorMessage("Token verification failed. Please check your Studio Token.");
                        showTokenValidationUI(false);
                    }
                } else {
                    showErrorMessage("Token verification failed. Please check your Studio Token.");
                    showTokenValidationUI(false);
                }
            } catch (error) {
                console.error("Error while checking Studio token:", error);
                showErrorMessage("Token verification error, please try again later.");
                showTokenValidationUI(false);
            }
            return null;
        }



        // åˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', function() {
            const userInfo = getUserAndChatIdFromUrl();
            if (!userInfo) {
                // å¦‚æœæ²¡æœ‰ç”¨æˆ·ä¿¡æ¯ï¼Œæ˜¾ç¤ºç™»å½•æç¤ºå¹¶ç¦ç”¨æ‰€æœ‰åŠŸèƒ½
                showLoginRequiredMessage();
                return;
            }

            // è®¾ç½®å…¨å±€å˜é‡
            userId = userInfo.userId;
            chatId = userInfo.chatId;

            userStateManager.setCurrentUser(chatId);
            setupEventListeners();
            setupConfigToggle(); // æ·»åŠ é…ç½®åŒºåŸŸæŠ˜å åŠŸèƒ½

            // å¦‚æœTokenå°šæœªéªŒè¯Doneï¼Œç¦ç”¨ç”¨æˆ·æ“ä½œ
            if (!isTokenValidated) {
                disableUserOperations();
            }
        });

        // æ˜¾ç¤º/éšè—TokenéªŒè¯UI
        function showTokenValidationUI(show) {
            const validationContainer = document.getElementById('tokenValidationContainer');
            if (validationContainer) {
                validationContainer.style.display = show ? 'block' : 'none';
            }
        }

        // ç¦ç”¨ç”¨æˆ·æ“ä½œï¼ˆTokenéªŒè¯æœŸé—´ï¼‰
        function disableUserOperations() {
            // ç¦ç”¨æ¿€æ´»ç¯å¢ƒæŒ‰é’®
            const activateBtn = document.getElementById('activateBtn');
            if (activateBtn) {
                activateBtn.disabled = true;
                activateBtn.innerHTML = '<span class="loading-spinner"></span> Waiting for verification...';
            }

            // ç¦ç”¨è¾“å…¥æ¡†å’Œå‘é€æŒ‰é’®
            const taskInput = document.getElementById('taskInput');
            const sendBtn = document.getElementById('sendBtn');
            if (taskInput) {
                taskInput.disabled = true;
                taskInput.placeholder = 'Please wait for verification to complete...';
            }
            if (sendBtn) {
                sendBtn.disabled = true;
            }

            // ç¦ç”¨é…ç½®ç›¸å…³çš„è¾“å…¥
            const configInputs = document.querySelectorAll('#configCardBody input, #configCardBody select');
            configInputs.forEach(input => {
                input.disabled = true;
            });
        }

        // å¯ç”¨ç”¨æˆ·æ“ä½œï¼ˆTokenéªŒè¯Doneåï¼‰
        function enableUserOperations() {
            // å¯ç”¨æ¿€æ´»ç¯å¢ƒæŒ‰é’®
            const activateBtn = document.getElementById('activateBtn');
            if (activateBtn) {
                activateBtn.disabled = false;
                activateBtn.innerHTML = '<i class="fas fa-bolt"></i> Activate Environment';
            }

            // ä¿æŒè¾“å…¥æ¡†å’Œå‘é€æŒ‰é’®ç¦ç”¨çŠ¶æ€ï¼ˆéœ€è¦å…ˆæ¿€æ´»ç¯å¢ƒï¼‰
            const taskInput = document.getElementById('taskInput');
            if (taskInput) {
                taskInput.placeholder = 'Activate the environment before entering a task...';
            }

            // å¯ç”¨é…ç½®ç›¸å…³çš„è¾“å…¥
            const configInputs = document.querySelectorAll('#configCardBody input, #configCardBody select');
            configInputs.forEach(input => {
                input.disabled = false;
            });
        }

        // æ˜¾ç¤ºéœ€è¦ç™»å½•çš„æç¤ºä¿¡æ¯
        function showLoginRequiredMessage() {
            // ç¦ç”¨æ‰€æœ‰æ“ä½œæŒ‰é’®
            const buttons = document.querySelectorAll('button');
            buttons.forEach(button => {
                button.disabled = true;
            });

            // ç¦ç”¨è¾“å…¥æ¡†
            const inputs = document.querySelectorAll('input, select');
            inputs.forEach(input => {
                input.disabled = true;
            });

            // åœ¨é¡µé¢é¡¶éƒ¨æ˜¾ç¤ºç™»å½•æç¤ºä¿¡æ¯
            const loginMessage = document.createElement('div');
            loginMessage.id = 'loginRequiredMessage';
            loginMessage.innerHTML = `                <div style="background-color: #f8d7da; color: #721c24; border: 1px solid #f5c6cb;
                            padding: 15px; border-radius: 5px; margin: 20px; text-align: center;
                            font-size: 18px; font-weight: bold;">
                    <i class="fas fa-exclamation-triangle"></i> Please sign in to use the system
                </div>
            `;

            // æ’å…¥åˆ°é¡µé¢é¡¶éƒ¨
            const container = document.querySelector('.container-fluid');
            if (container) {
                container.insertBefore(loginMessage, container.firstChild);
            }
        }

        // è®¾ç½®äº‹ä»¶ç›‘å¬å™¨
        function setupEventListeners() {
            document.getElementById('activateBtn').addEventListener('click', activateEnvironment);
            document.getElementById('sendBtn').addEventListener('click', sendTask);
            document.getElementById('clearBtn').addEventListener('click', clearChat);
            document.getElementById('stopTaskBtn').addEventListener('click', stopTask);
            document.getElementById('taskInput').addEventListener('keypress', function(e) {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    sendTask();
                }
            });
            document.getElementById('deviceSelect').addEventListener('change', handleDeviceSelectChange);

            // æ–°å¢çš„äº‹ä»¶ç›‘å¬å™¨
            document.getElementById('pipelineTypeSelect').addEventListener('change', function() {
                console.log('Pipeline type changed to:', this.value);
                toggleAgentFrameworkInput();
                saveE2eConfigToUserState();
            });
            document.getElementById('modelNameInput').addEventListener('input', saveE2eConfigToUserState);
            document.getElementById('agentFrameworkInput').addEventListener('input', saveE2eConfigToUserState);
            document.getElementById('extraParamsInput').addEventListener('input', saveE2eConfigToUserState);
            document.getElementById('deepThinkingSelect').addEventListener('input', saveE2eConfigToUserState);

            // é¡µé¢å…³é—­å‰é‡Šæ”¾èµ„æº
            window.addEventListener('beforeunload', handlePageUnload);

            // ğŸ”§ æ–°å¢ï¼šé¡µé¢åˆå§‹åŒ–Doneåï¼Œä¸»åŠ¨è°ƒç”¨ä¸€æ¬¡toggleAgentFrameworkInputç¡®ä¿ç•Œé¢çŠ¶æ€æ­£ç¡®
            setTimeout(() => {
                toggleAgentFrameworkInput();
            }, 100);
        }

        // å¤„ç†è®¾å¤‡é€‰æ‹©å˜æ›´
        function handleDeviceSelectChange() {
            const selectedValue = document.getElementById('deviceSelect').value;
            updateSandboxTypeState(selectedValue);

            // å½“è®¾å¤‡ç±»å‹æ”¹å˜æ—¶ï¼Œå¦‚æœå½“å‰æ˜¯agentæ¨¡å¼ï¼Œåˆ™æ›´æ–°agentæ¡†æ¶åç§°
            const pipelineType = document.getElementById('pipelineTypeSelect').value;
            if (pipelineType !== 'e2e') {
                const agentFrameworkInput = document.getElementById('agentFrameworkInput');
                // ğŸ”§ ä¿®å¤ï¼šè®¾å¤‡ç±»å‹å˜æ›´æ—¶ï¼Œæ€»æ˜¯æ›´æ–°agentæ¡†æ¶åç§°ï¼ˆé™¤éå¯¹è¯æ‰‹åŠ¨è¾“å…¥äº†è‡ªå®šä¹‰å€¼ï¼‰

                // æ£€æŸ¥å½“å‰å€¼æ˜¯å¦ä¸ºé»˜è®¤å€¼æˆ–ç©ºå€¼ï¼Œå¦‚æœæ˜¯ï¼Œåˆ™æ›´æ–°ä¸ºæ–°è®¾å¤‡ç±»å‹çš„é»˜è®¤å€¼
                const currentValue = agentFrameworkInput.value;
                const isDefaultValue = currentValue === 'mobile-agent-pipeline' ||
                                     currentValue === 'pre-pc-agent-e' ||
                                     !currentValue ||
                                     currentValue.trim() === '';

                if (isDefaultValue) {
                    if (selectedValue.includes('phone')) {
                        agentFrameworkInput.value = 'mobile-agent-pipeline';
                    } else {
                        agentFrameworkInput.value = 'pre-pc-agent-e';
                    }
                    console.log('Updated agent framework for device change:', agentFrameworkInput.value);
                    saveE2eConfigToUserState();
                }
            }

            /* æ–°å¢ï¼šé‡ç»˜å¿«æ·æŒ‰é’® */
            renderQuickCommands();
            /* ä¸‹é¢åŸæœ‰ä»£ç ä¸åŠ¨ */
        }

        // åˆ‡æ¢agentæ¡†æ¶è¾“å…¥æ¡†çš„å¯ç”¨/ç¦ç”¨çŠ¶æ€
        function toggleAgentFrameworkInput() {
            const pipelineType = document.getElementById('pipelineTypeSelect').value;
            const agentFrameworkInput = document.getElementById('agentFrameworkInput');
            const deviceSelectValue = document.getElementById('deviceSelect').value;

            if (pipelineType === 'e2e') {
                // æ¨¡å‹ç›´ä¼ æ—¶ç¦ç”¨agentæ¡†æ¶åç§°è¾“å…¥æ¡†å¹¶æ¸…ç©ºå€¼
                agentFrameworkInput.disabled = true;
                agentFrameworkInput.classList.add('device-select-disabled');
                agentFrameworkInput.value = ''; // æ¸…ç©ºå€¼ï¼Œå› ä¸ºæ¨¡å‹ç›´ä¼ ä¸éœ€è¦Agentæ¡†æ¶
            } else {
                // agentæ¡†æ¶æ—¶å¯ç”¨agentæ¡†æ¶åç§°è¾“å…¥æ¡†
                agentFrameworkInput.disabled = false;
                agentFrameworkInput.classList.remove('device-select-disabled');

                // ğŸ”§ ä¿®å¤ï¼šæ— è®ºå½“å‰å€¼æ˜¯å¦ä¸ºç©ºï¼Œéƒ½å°è¯•è®¾ç½®é»˜è®¤å€¼ï¼ˆä½†ä¸è¦†ç›–å¯¹è¯æ‰‹åŠ¨è¾“å…¥çš„å€¼ï¼‰
                if (!agentFrameworkInput.value || agentFrameworkInput.value.trim() === '') {
                    if (deviceSelectValue.includes('phone')) {
                        agentFrameworkInput.value = 'mobile-agent-pipeline';
                    } else {
                        agentFrameworkInput.value = 'pre-pc-agent-e';
                    }
                    console.log('Auto-filled agent framework:', agentFrameworkInput.value);
                }
            }
            // æ— è®ºå“ªç§æ¨¡å¼éƒ½ä¿å­˜é…ç½®çŠ¶æ€
            saveE2eConfigToUserState();
        }

        // è®¾ç½®é…ç½®åŒºåŸŸæŠ˜å åŠŸèƒ½
        function setupConfigToggle() {
            const header = document.getElementById('configCardHeader');
            const body = document.getElementById('configCardBody');
            const icon = document.getElementById('configToggleIcon');

            header.addEventListener('click', function() {
                // åˆ‡æ¢æŠ˜å çŠ¶æ€
                const isCollapsed = body.classList.toggle('collapsed');
                icon.classList.toggle('collapsed', isCollapsed);
            });
        }

        // é¡µé¢å…³é—­å‰å¤„ç†
        // é¡µé¢å…³é—­å‰å¤„ç†
        function handlePageUnload(event) {
        const currentUserState = getCurrentUserState();
        if (currentUserState && (currentUserState.isActivated || currentUserState.isActivating)) {
            // æ„é€ è¯·æ±‚ä½“æ•°æ®
            const requestData = {
                user_id: userId,
                chat_id: chatId
            };

            // ä½¿ç”¨ sendBeacon å‘é€é‡Šæ”¾èµ„æºè¯·æ±‚ï¼Œè¿™åœ¨é¡µé¢å¸è½½æ—¶æ›´å¯é 
            const releaseUrl = `${getBackendUrl()}/cua/release`;

            // å‡†å¤‡å‘é€çš„æ•°æ®
            const data = JSON.stringify(requestData);

            // å°è¯•ä½¿ç”¨ sendBeaconï¼ˆæ›´å¯é ï¼‰
            if (navigator.sendBeacon) {
                navigator.sendBeacon(releaseUrl, new Blob([data], { type: 'application/json' }));
            } else {
                // é™çº§åˆ° fetchï¼ˆä½†å¯èƒ½ä¸ä¼šè¢«æµè§ˆå™¨ç­‰å¾…Doneï¼‰
                fetch(releaseUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: data
                }).catch(error => {
                    console.error('Failed to release resources:', error);
                });
            }
        }
        stopHeartbeat();
        stopSSEMonitoring();
        stopQueueMonitoring();  // ğŸ”§ æ–°å¢ï¼šåœæ­¢æ’é˜Ÿç›‘æ§

        // ğŸ”§ æ–°å¢ï¼šåœæ­¢ç­‰å¾…å€’è®¡æ—¶
        if (currentUserState) {
            stopWaitingCountdown(currentUserState);
        }
        }


        // ä¿å­˜æ·±åº¦æ€è€ƒçŠ¶æ€
        function saveDeepThinkingToUserState() {
            const val = document.getElementById('deepThinkingSelect').value === 'true';
            updateCurrentUserState({ deepThinking: val });
        }

        // æ˜¾ç¤ºé”™è¯¯æ¶ˆæ¯
        function showErrorMessage(message) {
            const errorContainer = document.getElementById('errorMessageContainer');
            const errorText = document.getElementById('errorMessageText');

            if (errorContainer && errorText) {
                errorText.textContent = message;
                errorContainer.style.display = 'block';

                // 3ç§’åè‡ªåŠ¨éšè—é”™è¯¯æ¶ˆæ¯
                setTimeout(() => {
                    if (errorContainer) {
                        errorContainer.style.display = 'none';
                    }
                }, 5000);
            }
        }

        // éšè—é”™è¯¯æ¶ˆæ¯
        function hideErrorMessage() {
            const errorContainer = document.getElementById('errorMessageContainer');
            if (errorContainer) {
                errorContainer.style.display = 'none';
            }
        }

        // ä¿å­˜e2eé…ç½®åˆ°å¯¹è¯çŠ¶æ€
        function saveE2eConfigToUserState() {
            const config = {
                pipelineType: document.getElementById('pipelineTypeSelect').value,
                modelName: document.getElementById('modelNameInput').value,
                agentFramework: document.getElementById('agentFrameworkInput').value,
                extraParams: document.getElementById('extraParamsInput').value,
                deepThink: document.getElementById('deepThinkingSelect').value
            };
            updateCurrentUserState({ e2eConfig: config });
        }

        // ä»å¯¹è¯çŠ¶æ€åŠ è½½e2eé…ç½®
        function loadE2eConfigFromUserState() {
            const currentUserState = getCurrentUserState();
            const deviceSelectValue = document.getElementById('deviceSelect').value;
            if (currentUserState && currentUserState.e2eConfig) {
                const config = currentUserState.e2eConfig;
                document.getElementById('pipelineTypeSelect').value = config.pipelineType;
                document.getElementById('modelNameInput').value = config.modelName;
                document.getElementById('agentFrameworkInput').value = config.agentFramework;
                document.getElementById('extraParamsInput').value = config.extraParams;
                document.getElementById('deepThinkingSelect').value = config.deepThink;
                // è§¦å‘agentæ¡†æ¶è¾“å…¥æ¡†çŠ¶æ€æ›´æ–°
                toggleAgentFrameworkInput();
            } else {
                // å¦‚æœæ²¡æœ‰å¯¹è¯çŠ¶æ€ï¼Œè®¾ç½®é»˜è®¤å€¼
                const pipelineType = document.getElementById('pipelineTypeSelect').value;
                const modelNameInput = document.getElementById('modelNameInput');
                const agentFrameworkInput = document.getElementById('agentFrameworkInput');
                const deepThink = document.getElementById('deepThinkingSelect');

                // ä»…å½“å¯¹è¯æœªè¾“å…¥æ—¶è®¾ç½®é»˜è®¤æ¨¡å‹åç§°
<!--                if (pipelineType === 'e2e' && !modelNameInput.value) {-->
<!--                    modelNameInput.value = 'qwen2.5-vl-72b-instruct-agent';-->
<!--                }-->

                // ä»…å½“å¯¹è¯æœªè¾“å…¥æ—¶è®¾ç½®é»˜è®¤agentæ¡†æ¶åç§°
                if (pipelineType !== 'e2e' && !agentFrameworkInput.value) {
                    if (deviceSelectValue.includes('phone')) {
                        agentFrameworkInput.value = 'mobile-agent-pipeline';
                    } else {
                        agentFrameworkInput.value = 'pre-pc-agent-e';
                    }
                }

                // ğŸ”§ æ–°å¢ï¼šæ— è®ºæ˜¯å¦æœ‰å¯¹è¯çŠ¶æ€ï¼Œéƒ½è¦è°ƒç”¨ä¸€æ¬¡toggleAgentFrameworkInputæ¥ç¡®ä¿ç•Œé¢çŠ¶æ€æ­£ç¡®
                toggleAgentFrameworkInput();
            }
        }

        // æ„å»ºe2e_infoå‚æ•°
        function buildE2eInfo() {
            const currentUserState = getCurrentUserState();
            let pipelineType, modelName, agentFramework, deviceSelectValue, deepThink;

            // ä¼˜å…ˆä½¿ç”¨å¯¹è¯çŠ¶æ€ä¸­çš„é…ç½®ï¼Œå¦‚æœæ²¡æœ‰åˆ™ä»DOMè·å–ï¼ˆå‘åå…¼å®¹ï¼‰
            if (currentUserState && currentUserState.e2eConfig) {
                const config = currentUserState.e2eConfig;
                pipelineType = config.pipelineType;
                modelName = config.modelName;
                agentFramework = config.agentFramework;
                deviceSelectValue = document.getElementById('deviceSelect').value;
                deepThink = config.deepThink;
            } else {
                deviceSelectValue = document.getElementById('deviceSelect').value;
                modelName = document.getElementById('modelNameInput').value;
                pipelineType = document.getElementById('pipelineTypeSelect').value;
                agentFramework = document.getElementById('agentFrameworkInput').value;
                deepThink = document.getElementById('deepThinkingSelect').value;

            }

            const deviceType = deviceSelectValue.includes('phone') ? 'mobile' : 'pc';

            // æ ¹æ®è°ƒç”¨æ–¹å¼æ„å»ºä¸åŒçš„e2e_infoç»“æ„
            if (pipelineType === 'e2e') {
                // æ¨¡å‹ç›´ä¼ æ¨¡å¼
                // å¦‚æœå¯¹è¯æ²¡æœ‰å¡«å†™æ¨¡å‹åç§°ï¼Œåˆ™ä½¿ç”¨é»˜è®¤å€¼
<!--                if (!modelName) {-->
<!--                    modelName = 'qwen2.5-vl-72b-instruct-agent';-->
<!--                }-->
                return [
<!--                    {"device_type": deviceType},-->
                    {"model_name": modelName},
                    {"pipeline_type": 'e2e'},
<!--                    {"use_add_info_generate": deepThink}-->
                ];
            } else {
                // agentæ¡†æ¶æ¨¡å¼
                // æ£€æŸ¥æ¨¡å‹åç§°æ˜¯å¦ä¸ºç©º
<!--                if (!modelName) {-->
<!--                    modelName = 'qwen2.5-vl-72b-instruct-agent';-->
<!--                }-->

                // å¦‚æœå¯¹è¯æ²¡æœ‰å¡«å†™æ¡†æ¶åç§°ï¼Œåˆ™æ ¹æ®è®¾å¤‡ç±»å‹è‡ªåŠ¨å¡«å……
                if (!agentFramework) {
                    if (deviceSelectValue.includes('phone')) {
                        agentFramework = 'mobile-agent-pipeline';
                    } else {
                        agentFramework = 'pre-pc-agent-e';
                    }
                }
                return [
<!--                    {"device_type": deviceType},-->
                    {"model_name": modelName},
                    {"pipeline_type": 'agent'},
<!--                    {"pipeline_name": agentFramework}-->
<!--                    {"use_add_info_generate": deepThink}-->
                ];
            }
        }

        // è·å–é¢å¤–å‚æ•°
        function getExtraParams() {
            const currentUserState = getCurrentUserState();
            // ä¼˜å…ˆä½¿ç”¨å¯¹è¯çŠ¶æ€ä¸­çš„é…ç½®ï¼Œå¦‚æœæ²¡æœ‰åˆ™ä»DOMè·å–ï¼ˆå‘åå…¼å®¹ï¼‰
            if (currentUserState && currentUserState.e2eConfig) {
                return currentUserState.e2eConfig.extraParams;
            } else {
                return document.getElementById('extraParamsInput').value;
            }
        }

        // æ¿€æ´»ç¯å¢ƒ
        async function activateEnvironment() {
            const activateBtn = document.getElementById('activateBtn');
            activateBtn.disabled = true;
            activateBtn.classList.add('btn-disabled');
            activateBtn.innerHTML = '<span class="loading-spinner"></span> Activating...';

            // ğŸ”§ æ–°å¢ï¼šè®¾ç½®æ­£åœ¨æ¿€æ´»çŠ¶æ€ï¼Œç¡®ä¿é¡µé¢å…³é—­æ—¶èƒ½æ­£ç¡®é‡Šæ”¾èµ„æº
            updateCurrentUserState({ isActivating: true });

            hideErrorMessage();

            try {
                // ä½¿ç”¨è®¾å¤‡é€‰æ‹©ä¸‹æ‹‰æ¡†çš„å½“å‰å€¼
                const selectedSandboxType = document.getElementById('deviceSelect').value;

                // æ„å»ºe2e_infoå‚æ•°
                const e2eInfo = buildE2eInfo();
                const extraParams = getExtraParams();

                const config = {
                    mode: isPhoneSandboxType(selectedSandboxType) ? 'phone_use' : 'pc_use',
                    sandbox_type: selectedSandboxType,
                    max_steps: parseInt(document.getElementById('maxStepsInput').value),
                    pc_use_addon_info: document.getElementById('addonInfoInput').value,
                    user_id: userId,
                    chat_id: chatId,
                    e2e_info: e2eInfo,
                    extra_params: extraParams
                };

                // æ·»åŠ æç¤ºä¿¡æ¯ï¼Œå‘ŠçŸ¥å¯¹è¯åˆå§‹åŒ–å¯èƒ½éœ€è¦è¾ƒé•¿æ—¶é—´
                addMessage('assistant', 'â³ Starting asynchronous environment activation, please wait...', 'status');

                // ğŸ”§ ä¿®æ”¹ï¼šè°ƒç”¨æ–°çš„å¼‚æ­¥æ¿€æ´»æ¥å£
                const response = await fetch(`${getBackendUrl()}/cua/init`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        config: config
                    })
                });

                if (response.status === 200) {
                    const result = await response.json();
                    const operationId = result.operation_id;

                    // ğŸ”§ æ–°å¢ï¼šå¯åŠ¨è½®è¯¢æ“ä½œçŠ¶æ€
                    addMessage('assistant', `âœ… Async activation started! Operation ID: ${operationId}\nPolling status...`, 'status');

                    // å¼€å§‹è½®è¯¢æ“ä½œçŠ¶æ€
                    await pollOperationStatus(operationId, 'init');

                } else if (response.status === 429) {
                    // è¿›å…¥æ’é˜ŸçŠ¶æ€
                    const errorDetail = await response.json();
                    if (errorDetail.detail && errorDetail.detail.type === 'queued') {
                        updateCurrentUserState({
                            isQueued: true,
                            isActivating: false, // ğŸ”§ è¿›å…¥æ’é˜Ÿï¼Œæ¸…é™¤æ¿€æ´»ä¸­çŠ¶æ€
                            queueInfo: errorDetail.detail
                        });
                        updateQueueInfo(errorDetail.detail);
                        startHeartbeat();

                        // ğŸ”§ æ–°å¢ï¼šæ’é˜ŸçŠ¶æ€ä¸‹ä¹Ÿè¦å¯åŠ¨SSEç›‘æ§æ¥æ¥æ”¶èµ„æºå¯ç”¨é€šçŸ¥
                        startSSEMonitoring();

                        // ğŸ”§ æ–°å¢ï¼šStart queue status monitoring
                        startQueueMonitoring();

                        // æ›´æ–°æŒ‰é’®çŠ¶æ€ä¸ºæ’é˜ŸçŠ¶æ€
                        activateBtn.innerHTML = '<i class="fas fa-clock"></i> Waiting in queue...';
                        activateBtn.disabled = true;
                        activateBtn.classList.add('btn-disabled');

                        // æ˜¾ç¤ºæ’é˜Ÿæ¶ˆæ¯
                        addMessage('assistant', `â³ ç³»ç»Ÿç¹å¿™ï¼Œå·²åŠ å…¥æ’é˜Ÿé˜Ÿåˆ—...\næ’é˜Ÿä½ç½®: ${errorDetail.detail.queue_position}/${errorDetail.detail.total_waiting}`, 'status');
                    } else {
                        // ğŸ”§ å…¶ä»–æƒ…å†µä¹Ÿè¦æ¸…é™¤æ¿€æ´»ä¸­çŠ¶æ€
                        updateCurrentUserState({ isActivating: false });
                    }
                } else if (response.status === 401 || response.status === 403) {
                    // æƒé™é”™è¯¯
                    updateCurrentUserState({ isActivating: false }); // ğŸ”§ æ¸…é™¤æ¿€æ´»ä¸­çŠ¶æ€
                    const errorData = await response.json();
                    showErrorMessage(`Permission error: ${errorData.detail || 'Login expired, please sign in again'}`);
                    addMessage('assistant', `âŒ Permission error: ${errorData.detail || 'Login expired, please sign in again'}`, 'status');
                } else if (response.status >= 500) {
                    // æœåŠ¡å™¨é”™è¯¯
                    updateCurrentUserState({ isActivating: false }); // ğŸ”§ æ¸…é™¤æ¿€æ´»ä¸­çŠ¶æ€
                    showErrorMessage('Internal server error, please try again later.');
                    addMessage('assistant', `âŒ Server error: HTTP ${response.status}`, 'status');
                } else {
                    // ğŸ”§ å…¶ä»–é”™è¯¯ï¼Œæ¸…é™¤æ¿€æ´»ä¸­çŠ¶æ€å¹¶æ¢å¤æŒ‰é’®
                    updateCurrentUserState({ isActivating: false });
                    const errorText = await response.text();
                    showErrorMessage(`Environment activation failed: HTTP ${response.status}`);
                    addMessage('assistant', `âŒ Environment activation failed: HTTP ${response.status}\n${errorText}`, 'status');
                    // æ¿€æ´»å¤±è´¥ï¼Œæ¢å¤æŒ‰é’®çŠ¶æ€
                    activateBtn.disabled = false;
                    activateBtn.classList.remove('btn-disabled');
                    activateBtn.innerHTML = '<i class="fas fa-bolt"></i> Activate Environment';
                }
            } catch (error) {
                // ğŸ”§ å¼‚å¸¸æƒ…å†µï¼Œæ¸…é™¤æ¿€æ´»ä¸­çŠ¶æ€å¹¶æ¢å¤æŒ‰é’®
                updateCurrentUserState({ isActivating: false });
                showErrorMessage(`Connection error: ${error.message}`);
                addMessage('assistant', `âŒ Connection error: ${error.message}`, 'status');
                // æ¿€æ´»å¤±è´¥ï¼Œæ¢å¤æŒ‰é’®çŠ¶æ€
                activateBtn.disabled = false;
                activateBtn.classList.remove('btn-disabled');
                activateBtn.innerHTML = '<i class="fas fa-bolt"></i> Activate Environment';
            }
        }

        // ğŸ”§ æ–°å¢ï¼šè½®è¯¢æ“ä½œçŠ¶æ€å‡½æ•°
        async function pollOperationStatus(operationId, operationType) {
            const maxPolls = 60; // æœ€å¤§è½®è¯¢æ¬¡æ•°ï¼ˆ5åˆ†é’Ÿï¼Œæ¯5ç§’ä¸€æ¬¡ï¼‰
            const pollInterval = 5000; // è½®è¯¢é—´éš”ï¼ˆæ¯«ç§’ï¼‰
            let pollCount = 0;

            // ğŸ”§ æ–°å¢ï¼šç¡®ä¿åœ¨è½®è¯¢æœŸé—´å¿ƒè·³ä¿æŒæ´»è·ƒ
            if (!heartbeatInterval) {
                startHeartbeat();
            }

            const poll = async () => {
                try {
                    pollCount++;
                    console.log(`Polling operation ${operationId}, attempt ${pollCount}`);

                    const response = await fetch(`${getBackendUrl()}/cua/operation_status?user_id=${userId}&chat_id=${chatId}&operation_id=${operationId}`);

                    if (response.status === 200) {
                        const statusData = await response.json();
                        console.log('Operation status:', statusData);

                        // ğŸ”§ ä¼˜åŒ–ï¼šåªåœ¨æ“ä½œDoneæˆ–å¤±è´¥æ—¶æ˜¾ç¤ºæ¶ˆæ¯ï¼Œé¿å…ä¸­é—´è¿›åº¦åˆ·å±
                        // if (statusData.progress !== undefined) {
                        //     addMessage('assistant', `ğŸ“Š ${statusData.message} (progress: ${statusData.progress}%)`, 'status');
                        // } else {
                        //     addMessage('assistant', `ğŸ“Š ${statusData.message}`, 'status');
                        // }

                        // æ£€æŸ¥æ“ä½œæ˜¯å¦Done
                        if (statusData.status === 'completed') {
                            // ğŸ”§ ç¯å¢ƒæ¿€æ´»æˆåŠŸDone - æ˜¾ç¤ºæœ€ç»ˆDoneæ¶ˆæ¯
                            addMessage('assistant', `âœ… ${statusData.message}`, 'status');
                            const result = statusData.result;

                            const resolvedSandboxType = statusData.result?.sandbox_type || document.getElementById('deviceSelect').value;
                            updateCurrentUserState({
                                isActivated: true,
                                isActivating: false // ğŸ”§ æ¿€æ´»æˆåŠŸï¼Œæ¸…é™¤æ¿€æ´»ä¸­çŠ¶æ€
                            });
                            updateSandboxTypeState(resolvedSandboxType);

                            // æ›´æ–°çŠ¶æ€
                            updateSandboxPreview(result);

                            // ğŸ”§ ç§»é™¤é‡å¤çš„æˆåŠŸæ¶ˆæ¯ï¼Œå·²åœ¨ä¸Šé¢æ˜¾ç¤ºåç«¯æ¶ˆæ¯
                            // addMessage('assistant', 'âœ… Environment activated!', 'status');

                            // å¯ç”¨ä»»åŠ¡è¾“å…¥
                            document.getElementById('taskInput').disabled = false;
                            document.getElementById('sendBtn').disabled = false;
                            // ç¦ç”¨è®¾å¤‡é€‰æ‹©
                            const deviceSelect = document.getElementById('deviceSelect');
                            deviceSelect.classList.add('device-select-disabled');
                            deviceSelect.disabled = true;

                            // å¯åŠ¨å¿ƒè·³
                            startHeartbeat();

                            // å¯åŠ¨å€’è®¡æ—¶
                            startCountdown();

                            // æ›´æ–°æ¿€æ´»æŒ‰é’®çŠ¶æ€ä¸ºæˆåŠŸå¹¶ç½®ç°
                            const activateBtn = document.getElementById('activateBtn');
                            activateBtn.innerHTML = '<i class="fas fa-check"></i> Activation Complete';

                            return; // Doneï¼Œåœæ­¢è½®è¯¢
                        } else if (statusData.status === 'failed') {
                            // æ“ä½œå¤±è´¥
                            updateCurrentUserState({ isActivating: false }); // ğŸ”§ æ¸…é™¤æ¿€æ´»ä¸­çŠ¶æ€
                            showErrorMessage(`Environment activation failed: ${statusData.error || 'Unknown error'}`);
                            addMessage('assistant', `âŒ Environment activation failed: ${statusData.error || 'Unknown error'}`, 'status');

                            // æ¿€æ´»å¤±è´¥ï¼Œæ¢å¤æŒ‰é’®çŠ¶æ€
                            const activateBtn = document.getElementById('activateBtn');
                            activateBtn.disabled = false;
                            activateBtn.classList.remove('btn-disabled');
                            activateBtn.innerHTML = '<i class="fas fa-bolt"></i> Activate Environment';

                            return; // å¤±è´¥ï¼Œåœæ­¢è½®è¯¢
                        } else if (statusData.status === 'queued') {
                            // ğŸ”§ æ–°å¢ï¼šå¤„ç†æ’é˜ŸçŠ¶æ€
                            updateCurrentUserState({
                                isQueued: true,
                                isActivating: false,
                                queueInfo: statusData.data
                            });

                            // æ˜¾ç¤ºæ’é˜Ÿä¿¡æ¯
                            addMessage('assistant', `â³ ${statusData.message}`, 'status');

                            // æ›´æ–°UIçŠ¶æ€
                            const activateBtn = document.getElementById('activateBtn');
                            activateBtn.innerHTML = '<i class="fas fa-clock"></i> Waiting in queue...';
                            activateBtn.disabled = true;
                            activateBtn.classList.add('btn-disabled');

                            // ç»§ç»­è½®è¯¢ï¼Œä½†å»¶é•¿é—´éš”
                            if (pollCount < maxPolls) {
                                setTimeout(poll, pollInterval * 2); // æ’é˜Ÿæ—¶åŒå€é—´éš”
                            } else {
                                updateCurrentUserState({ isActivating: false });
                                showErrorMessage('Queue wait timed out, please refresh and try again.');
                                addMessage('assistant', 'â° Queue wait timed out, please refresh and try again.', 'status');

                                activateBtn.disabled = false;
                                activateBtn.classList.remove('btn-disabled');
                                activateBtn.innerHTML = '<i class="fas fa-bolt"></i> Activate Environment';
                            }
                        } else if (statusData.status === 'waiting_retry') {
                            // ğŸ”§ æ–°å¢ï¼šå¤„ç†ç­‰å¾…é‡è¯•çŠ¶æ€
                            addMessage('assistant', `ğŸ”„ ${statusData.message}`, 'status');

                            // æ›´æ–°UIçŠ¶æ€
                            const activateBtn = document.getElementById('activateBtn');
                            activateBtn.innerHTML = '<i class="fas fa-sync-alt fa-spin"></i> Retrying automatically...';

                            // ç»§ç»­è½®è¯¢
                            if (pollCount < maxPolls) {
                                setTimeout(poll, pollInterval);
                            } else {
                                updateCurrentUserState({ isActivating: false });
                                showErrorMessage('Automatic retry timed out, please try again manually.');

                                activateBtn.disabled = false;
                                activateBtn.classList.remove('btn-disabled');
                                activateBtn.innerHTML = '<i class="fas fa-bolt"></i> Activate Environment';
                            }
                        } else {
                            // ä»åœ¨è¿›è¡Œä¸­ï¼Œç»§ç»­è½®è¯¢
                            if (pollCount < maxPolls) {
                                setTimeout(poll, pollInterval);
                            } else {
                                // è½®è¯¢è¶…æ—¶
                                updateCurrentUserState({ isActivating: false }); // ğŸ”§ æ¸…é™¤æ¿€æ´»ä¸­çŠ¶æ€
                                showErrorMessage('Environment activation timed out, please try again later.');
                                addMessage('assistant', 'â° Environment activation timed out, please try again later.', 'status');

                                // æ¢å¤æŒ‰é’®çŠ¶æ€
                                const activateBtn = document.getElementById('activateBtn');
                                activateBtn.disabled = false;
                                activateBtn.classList.remove('btn-disabled');
                                activateBtn.innerHTML = '<i class="fas fa-bolt"></i> Activate Environment';
                            }
                        }
                    } else {
                        // è½®è¯¢è¯·æ±‚å¤±è´¥
                        console.error('Failed to poll status:', response.status);
                        if (pollCount < maxPolls) {
                            setTimeout(poll, pollInterval);
                        } else {
                            updateCurrentUserState({ isActivating: false });
                            showErrorMessage('Unable to get operation status, please refresh and try again.');
                        }
                    }
                } catch (error) {
                    console.error('Error while polling status:', error);
                    if (pollCount < maxPolls) {
                        setTimeout(poll, pollInterval);
                    } else {
                        updateCurrentUserState({ isActivating: false });
                        showErrorMessage(`Status polling error: ${error.message}`);
                    }
                }
            };

            // å¼€å§‹ç¬¬ä¸€æ¬¡è½®è¯¢
            setTimeout(poll, 1000); // 1ç§’åå¼€å§‹ç¬¬ä¸€æ¬¡è½®è¯¢
        }

        // å‘é€ä»»åŠ¡ - é€‚é…æ–°çš„backend /cua/runæ¥å£
        async function sendTask() {
            const currentUserState = getCurrentUserState();
            const taskInput = document.getElementById('taskInput');
            const taskText = taskInput.value.trim();

            if (!taskText) return;

            // æ–°ä»»åŠ¡å¼€å§‹ï¼Œæ¸…ç©ºä¸Šä¸€è½®çš„Plannerå±•ç¤º
            clearPlanner();

            // æ·»åŠ å¯¹è¯æ¶ˆæ¯
            addMessage('user', taskText);
            taskInput.value = '';

            // ç¦ç”¨è¾“å…¥
            taskInput.disabled = true;
            const sendBtn = document.getElementById('sendBtn');
            sendBtn.disabled = true;
            sendBtn.innerHTML = '<span class="loading-spinner"></span> Running...';

            // ä»»åŠ¡å¼€å§‹æ—¶ç¦ç”¨ç¯å¢ƒåˆ‡æ¢æŒ‰é’®
            // æ˜¾ç¤ºåœæ­¢æŒ‰é’®
            document.getElementById('stopTaskBtn').style.display = 'inline-block';

            try {
                // ä½¿ç”¨å½“å‰å¯¹è¯çŠ¶æ€ä¸­çš„ç¯å¢ƒç±»å‹
                const currentSandboxType = currentUserState.currentSandboxType;

                // æ„å»ºe2e_infoå‚æ•°
                const e2eInfo = buildE2eInfo();
                const extraParams = getExtraParams();

                // æ„å»ºç¬¦åˆComputerUseRequestæ ¼å¼çš„è¯·æ±‚
                const backendRequest = {
                    input: [{
                        role: "user",
                        content: [{
                            type: "text",
                            text: taskText
                        }]
                    }],
                    config: {
                        mode: currentSandboxType === 'phone_wuyin' ? 'phone_use' : 'pc_use',
                        sandbox_type: currentSandboxType,
                        max_steps: parseInt(document.getElementById('maxStepsInput').value),
                        pc_use_addon_info: document.getElementById('addonInfoInput').value,
                        timeout: 120,
                        user_id: userId,
                        chat_id: chatId,
                        e2e_info: e2eInfo,
                        extra_params: extraParams
                    },
                    stream: true
                };

                // è°ƒç”¨åç«¯çš„/cua/runæ¥å£
                const response = await fetch(`${getBackendUrl()}/cua/run`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(backendRequest)
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                // å¤„ç†æµå¼å“åº”
                await handleStreamResponse(response);

            } catch (error) {
                showErrorMessage(`Connection error: ${error.message}`);
                addMessage('assistant', `âŒ Connection error: ${error.message}`, 'status');
                resetTaskState();
                updateCurrentUserState({ all_subtasks_complete_handled: false });
            }
        }

        // å¤„ç†æµå¼å“åº”
        async function handleStreamResponse(response) {
            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            let buffer = '';

            try {
                while (true) {
                    const { done, value } = await reader.read();

                    if (done) {
                        console.log('Streaming response finished.');
                        break;
                    }

                    // è§£ç æ•°æ®å—
                    const chunk = decoder.decode(value, { stream: true });
                    buffer += chunk;

                    // å¤„ç†å®Œæ•´çš„SSEæ¶ˆæ¯
                    // ä½¿ç”¨\n\nä½œä¸ºæ¶ˆæ¯åˆ†éš”ç¬¦ï¼Œè¿™æ˜¯SSEçš„æ ‡å‡†æ ¼å¼
                    while (buffer.includes('\n\n')) {
                        const messageEndIndex = buffer.indexOf('\n\n');
                        const completeMessage = buffer.substring(0, messageEndIndex);
                        buffer = buffer.substring(messageEndIndex + 2);

                        // å¤„ç†å•æ¡å®Œæ•´æ¶ˆæ¯
                        const lines = completeMessage.split('\n');
                        for (const line of lines) {
                            if (line.startsWith('data: ')) {
                                try {
                                    const jsonData = line.substring(6).trim();
                                    if (jsonData && jsonData !== '') {
                                        const data = JSON.parse(jsonData);
                                        handleStreamData(data);
                                    }
                                } catch (e) {
                                    console.error('JSON parse error:', e, 'Line:', line, 'JsonData:', line.substring(6));
                                }
                            }
                        }
                    }
                }

                // å¤„ç†æœ€åå¯èƒ½å‰©ä½™çš„ä¸å®Œæ•´æ¶ˆæ¯
                if (buffer.trim()) {
                    console.warn('Buffer has remaining data:', buffer);
                }
            } catch (error) {
                console.error('Stream processing error:', error);
                showErrorMessage(`Streaming error: ${error.message}`);
                addMessage('assistant', `âŒ Streaming error: ${error.message}`, 'status');
                resetTaskState();
            }
        }

        // ç”Ÿæˆç®€å•çš„UUID
<!--        function generateUUID() {-->
<!--            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {-->
<!--                var r = Math.random() * 16 | 0,-->
<!--                    v = c == 'x' ? r : (r & 0x3 | 0x8);-->
<!--                return v.toString(16);-->
<!--            });-->
<!--        }-->

        // å¤„ç†æµå¼æ•°æ® - é€‚é…æ–°çš„åç«¯æ¥å£æ ¼å¼
        function handleStreamData(data) {
            console.log('Received stream data:', data);

            // æ–°çš„æ¥å£æ ¼å¼ï¼šæ‰€æœ‰å®é™…æ•°æ®éƒ½åœ¨dataå­—æ®µä¸­
            if (data.object === 'content' && data.type === 'data' && data.data) {
                const contentData = data.data;
                console.log('Processing content data:', contentData);

                const contentTypeRaw = contentData.type || '';
                const contentType = typeof contentTypeRaw === 'string'
                    ? contentTypeRaw.toLowerCase()
                    : '';

                // æ ¹æ®contentDataçš„typeå’Œstageæ¥å¤„ç†ä¸åŒç±»å‹çš„æ¶ˆæ¯
                if (contentType === 'analysis_stage') {
                    // å¤„ç†åˆ†æé˜¶æ®µæ¶ˆæ¯
                    console.log('[DEBUG] Processing analysis_stage message:', contentData);
                    const formattedData = {
                        type: 'analysis_stage',
                        data: {
                            stage: contentData.stage,
                            text: contentData.text || contentData.message, // å…¼å®¹textå’Œmessageå­—æ®µ
                            timestamp: contentData.timestamp,
                            uuid: contentData.uuid
                        },
                        uuid: contentData.uuid,
                        timestamp: contentData.timestamp
                    };
                    formatAnalysisStageMessage(formattedData);
                } else if (contentType === 'analysis_result') {
                    // å¤„ç†åˆ†æç»“æœæ¶ˆæ¯ï¼ˆå¯¹åº”åŸæ¥çš„STEPæ¶ˆæ¯ï¼‰
                    console.log('Processing analysis_result message:', contentData);
                    const formattedData = {
                        type: 'STEP',
                        data: {
                            step: contentData.step,
                            observation: contentData.text, // å°†textä½œä¸ºobservation
                            auxiliary_info: contentData.auxiliary_info || {}
                        },
                        task_id: 'current', // ä½¿ç”¨å›ºå®šå€¼
                        timestamp: contentData.timestamp || new Date().toISOString(),
<!--                        uuid: contentData.uuid || generateUUID()-->
                    };
                    formatStepMessage(formattedData);
                } else if (['plan', 'planner', 'planner_result', 'plan_result', 'planner_steps'].includes(contentType)) {
                    console.log('Processing planner message:', contentData);
                    handlePlannerContent(contentData);
                } else if (contentType === 'human_intervention') {
                    // å¤„ç†äººå·¥å¹²é¢„æ¶ˆæ¯
                    console.log('Processing human intervention message:', contentData);
                    addMessage('assistant', `ğŸ¤š ${contentData.text}`, 'status');

                    // æ˜¾ç¤ºäººå·¥å¹²é¢„ç•Œé¢
                    showHumanInterventionNotice(contentData);
                } else if (contentType === 'text' || contentType === 'output') {
                    // å¤„ç†æ™®é€šæ–‡æœ¬æ¶ˆæ¯
                    if (contentData.text) {
                        addMessage('assistant', contentData.text);
                    }
                } else {
                    // å…¶ä»–ç±»å‹çš„æ¶ˆæ¯ï¼Œç›´æ¥æ˜¾ç¤ºæ–‡æœ¬å†…å®¹
                    if (contentData.text) {
                        addMessage('assistant', contentData.text);
                    }
                }
            } else if (data.object === 'message') {
                // å…¼å®¹åŸæœ‰çš„Messageå¯¹è±¡æ ¼å¼
                if (data.content && Array.isArray(data.content)) {
                    for (const contentItem of data.content) {
                        if (contentItem.type === 'text') {
                            addMessage('assistant', contentItem.text);
                        }
                    }
                }
            } else {
                // å…¼å®¹åŸæœ‰æ ¼å¼ï¼Œå¤„ç†backendçš„SSEæ¶ˆæ¯
                switch (data.type) {
                    case 'task_started':
                        // ä»»åŠ¡å¼€å§‹
                        addMessage('assistant', 'âœ… Task started!', 'status');
                        if (data.task_id) {
                            updateCurrentUserState({
                                taskId: data.task_id,
                                processedMessages: new Set()
                            });
                            addMessage('assistant', `Task ID: ${data.task_id}`, 'status');
                        }
                        // æ›´æ–°æ²™ç›’é¢„è§ˆ
                        if (data.equipment_web_url || data.sandbox_url) {
                            updateSandboxPreview(data);
                        }
                        break;

                    case 'task_error':
                        // ä»»åŠ¡é”™è¯¯
                        if (data.error_code === 429) {
                            // æ’é˜ŸçŠ¶æ€å¤„ç†
                            handleQueueState(data);
                        } else {
                            showErrorMessage(`Task error: ${data.message}`);
                            addMessage('assistant', `âŒ Task error: ${data.message}`, 'status');
                            resetTaskState();
                        }
                        break;

                    case 'heartbeat':
                        // å¿ƒè·³åŒ…ï¼Œä¿æŒè¿æ¥
                        console.log('Heartbeat received');
                        break;

                    default:
                        // å…¶ä»–çŠ¶æ€æ›´æ–°ï¼Œä½¿ç”¨åŸæœ‰çš„SSEæ¶ˆæ¯å¤„ç†é€»è¾‘
                        handleSSEMessage(data);
                }
            }

            // æ£€æŸ¥ä»»åŠ¡æ˜¯å¦Doneï¼ˆå½“æ”¶åˆ°Doneæ¶ˆæ¯æ—¶é‡ç½®çŠ¶æ€ï¼‰
            if ((data.object === 'content' && data.type === 'data' && data.data && data.data.text &&
                 (data.data.text.includes('Task completed') || data.data.text.includes('Task completed') ||
                  data.data.text.includes('âœ… Task completed') || data.data.text.includes('Task cancelled') ||
                  data.data.text.includes('Reached the maximum step limit.') || data.data.text.includes('Task stopped'))) ||
                (data.object === 'content' && data.type === 'data' && data.data &&
                 data.data.stage === 'completed' && data.data.text && data.data.text.includes('Reached the maximum step limit.')) ||
                (data.type === 'SYSTEM' && data.status === 'stopped')) {
                console.log('Task completion detected, resetting task state');
                resetTaskState();
            }
        }

        // å¤„ç†æ’é˜ŸçŠ¶æ€
        function handleQueueState(errorData) {
            const detail = JSON.parse(errorData.message);
            if (detail.type === 'queued') {
                updateCurrentUserState({
                    isQueued: true,
                    queueInfo: detail
                });
                updateQueueInfo(detail);

                // Start queue status monitoring
                startQueueMonitoring();

                // ç¡®ä¿å¿ƒè·³ç›‘æ§æ­£åœ¨è¿è¡Œ
                if (!heartbeatInterval) {
                    startHeartbeat();
                }

                // æ˜¾ç¤ºæ’é˜Ÿä¿¡æ¯
                const queueMsg = `â„¹ï¸ System busy, queued...\nQueue position: ${detail.queue_position}/${detail.total_waiting}`;
                addMessage('assistant', queueMsg, 'status');
            }

            // é‡ç½®ä»»åŠ¡çŠ¶æ€ï¼Œè®©å¯¹è¯å¯ä»¥é‡æ–°å°è¯•
            resetTaskState();
        }

          // æ–°çš„åœæ­¢ä»»åŠ¡
        async function stopTask () {
          const stopBtn  = document.getElementById('stopTaskBtn');
          const taskInput = document.getElementById('taskInput');
          const sendBtn   = document.getElementById('sendBtn');

          // â‘  å…ˆæŠŠæŒ‰é’®è®¾ä¸º"Stoppingâ€¦"
          stopBtn.disabled = true;
          stopBtn.innerHTML =
              '<span class="loading-spinner"></span> Stopping...';

          try {
              const resp = await fetch(
                  `${getBackendUrl()}/cua/stop?user_id=${userId}&chat_id=${chatId}`,
                  {method: 'GET'}
              );

              if (resp.ok) {
                  // 200 â†’ å·²æŠŠåœæ­¢è¯·æ±‚å‘ç»™åç«¯
                  // ğŸ”§ ç§»é™¤è¿™é‡Œçš„æ¶ˆæ¯æ˜¾ç¤ºï¼Œè®©åç«¯SSEæ¶ˆæ¯æ¥å¤„ç†
                  // addMessage(
                  //     'assistant',
                  //     'â¹ï¸ Stop request sent, waiting for backend confirmation...',
                  //     'status'
                  // );
              } else {
                  // é 2xx ä»å½“ä½œé”™è¯¯å¤„ç†
                  const txt = await resp.text();
                  throw new Error(`HTTP ${resp.status} ${txt}`);
              }
          }
          catch (err) {
              // ç½‘ç»œæˆ–åç«¯è¿”å›é 2xx
              showErrorMessage(`Failed to stop task: ${err.message}`);
              addMessage(
                  'assistant',
                  `âŒ Failed to stop task: ${err.message}`,
                  'status'
              );
          }
          finally {
              /* â‘¡ ä¸è®ºæˆåŠŸè¿˜æ˜¯å¤±è´¥ï¼Œéƒ½æŠŠç•Œé¢è§£é” */

              // ğŸ”§ ä¿®å¤ï¼šä¸è¦åœ¨è¿™é‡Œè®¾ç½®isTaskRunningä¸ºfalseï¼Œåº”è¯¥ç­‰æ”¶åˆ°åç«¯ç¡®è®¤æ¶ˆæ¯
              // æœ¬åœ°çŠ¶æ€ç½®ä¸º"Not running"ï¼Œé¿å…ä¸èƒ½å†æ¬¡å‘é€
              // updateCurrentUserState({isTaskRunning: false});

              // è®©è¾“å…¥æ¡†ã€å‘é€æŒ‰é’®é‡æ–°å¯ç”¨
              taskInput.disabled = false;
              sendBtn.disabled   = false;
              sendBtn.innerHTML  = '<i class="fas fa-paper-plane"></i> Send';

              // éšè—åœæ­¢æŒ‰é’®ï¼ˆå¦‚æœä½ æƒ³ä¿ç•™å¯å†æ˜¾ç¤ºï¼‰
              stopBtn.style.display = 'none';
              stopBtn.disabled = false;
              stopBtn.innerHTML = '<i class="fas fa-stop"></i> Stop Task';

              // è¿˜åŸå…¶ä»– UI
              resetTaskState();          // æŠŠèŠå¤©ç­‰çŠ¶æ€æ¸…ç†
          }
        }


        // å¯åŠ¨SSEç›‘æ§ - å·²å¼ƒç”¨ï¼Œç°åœ¨ä½¿ç”¨æµå¼æ¥å£
        function startSSEMonitoring() {
            console.log('SSE monitoring is deprecated, using stream interface instead');
            // SSEç›‘æ§åŠŸèƒ½å·²ç»è¢«æµå¼æ¥å£å–ä»£
            return;
        }


        // åœæ­¢è½®è¯¢
        function stopPolling() {
            const currentUserState = getCurrentUserState();
            if (!currentUserState) return;

            if (currentUserState.pollInterval) {
                clearInterval(currentUserState.pollInterval);
                currentUserState.pollInterval = null;
            }
        }

        // åœæ­¢SSEç›‘æ§ - å·²å¼ƒç”¨ï¼Œç°åœ¨ä½¿ç”¨æµå¼æ¥å£
        function stopSSEMonitoring() {
            console.log('SSE monitoring is deprecated, using stream interface instead');
            // åœæ­¢è½®è¯¢ï¼ˆå¦‚æœæœ‰ï¼‰
            stopPolling();
            // åœæ­¢æ’é˜Ÿç›‘æ§
            stopQueueMonitoring();
        }

        // ğŸ”§ æ–°å¢ï¼šStart queue status monitoring
        function startQueueMonitoring() {
            const currentUserState = getCurrentUserState();
            if (!currentUserState) return;

            // å…ˆæ¸…ç†å·²æœ‰çš„æ’é˜Ÿç›‘æ§å®šæ—¶å™¨
            if (currentUserState.queueMonitorInterval) {
                clearInterval(currentUserState.queueMonitorInterval);
                currentUserState.queueMonitorInterval = null;
            }

        console.log('Start queue status monitoring');
        addMessage('assistant', 'ğŸ• Starting queue monitoring; checking resource availability periodically...', 'status');

            currentUserState.queueMonitorInterval = setInterval(async () => {
                try {
                    const userState = getCurrentUserState();
                    if (!userState || !userState.isQueued) {
                        // å¦‚æœä¸å†å¤„äºæ’é˜ŸçŠ¶æ€ï¼Œåœæ­¢ç›‘æ§
                        stopQueueMonitoring();
                        return;
                    }

                    // è·å–å½“å‰è®¾å¤‡é€‰æ‹©
                    const selectedSandboxType = document.getElementById('deviceSelect').value;

                    // æ£€æŸ¥é˜Ÿåˆ—çŠ¶æ€
                    const response = await fetch(
                        `${getBackendUrl()}/cua/queue_status?user_id=${userId}&chat_id=${chatId}&sandbox_type=${selectedSandboxType}`
                    );

                    if (response.ok) {
                        const queueData = await response.json();
                        console.log('Queue status result:', queueData);

                        // æ›´æ–°æ’é˜Ÿä¿¡æ¯æ˜¾ç¤º
                        if (queueData.position >= 0 && queueData.queue_status === 'queued') {
                            updateQueueInfo({
                                queue_position: queueData.position + 1,  // åç«¯è¿”å›çš„æ˜¯ç´¢å¼•ï¼Œå‰ç«¯æ˜¾ç¤ºæ—¶+1
                                total_waiting: queueData.total_waiting
                            });

                            // å¦‚æœæ’é˜Ÿä½ç½®å‘ç”Ÿå˜åŒ–ï¼Œæ˜¾ç¤ºæ›´æ–°æ¶ˆæ¯
                            if (userState.queueInfo &&
                                userState.queueInfo.queue_position !== (queueData.position + 1)) {
                                addMessage('assistant',
                                    `ğŸ“ Queue position updated: ${queueData.position + 1}/${queueData.total_waiting}`,
                                    'status');
                            }

                            // æ›´æ–°å¯¹è¯çŠ¶æ€ä¸­çš„æ’é˜Ÿä¿¡æ¯
                            updateCurrentUserState({
                                queueInfo: {
                                    queue_position: queueData.position + 1,
                                    total_waiting: queueData.total_waiting
                                }
                            });
                        } else if (queueData.position === -1) {
                            // æ ¹æ®è¯¦ç»†çŠ¶æ€åˆ¤æ–­å¦‚ä½•å¤„ç†
                            if (queueData.queue_status === 'allocated') {
                                // å¯¹è¯å·²æœ‰åˆ†é…çš„èµ„æºï¼Œåº”è¯¥è‡ªåŠ¨æ¿€æ´»
                                console.log('Detected allocated resources for the session, trying to reactivate.');
                                addMessage('assistant', 'âœ… Allocated resources detected, activating environment automatically...', 'status');

                                // åœæ­¢æ’é˜Ÿç›‘æ§
                                stopQueueMonitoring();

                                // å°è¯•é‡æ–°æ¿€æ´»ç¯å¢ƒ
                                setTimeout(autoReactivateEnvironment, 1000);
                            } else if (queueData.queue_status === 'not_queued') {
                                // ğŸ”§ ä¼˜åŒ–ï¼šå¯¹è¯ä¸åœ¨é˜Ÿåˆ—ä¸”æ— åˆ†é…èµ„æºæ—¶çš„å¤„ç†
                                console.log('Session not currently in queue; resources may become available soon, keep monitoring...');

                                // æ˜¾ç¤ºç­‰å¾…çŠ¶æ€ï¼Œä½†ä¸è¦é¢‘ç¹æ›´æ–°UI
                                if (!userState.queueInfo || userState.queueInfo.queue_position !== 'Waiting') {
                                    updateQueueInfo({
                                        queue_position: 'Waiting',
                                        total_waiting: 'Checking resource status...'
                                    });
                                }

                                // å¼€å§‹ç­‰å¾…å€’è®¡æ—¶ï¼Œå¦‚æœæ²¡æœ‰åœ¨å€’è®¡æ—¶ä¸­çš„è¯
                                if (!userState.waitingCountdown) {
                                    startWaitingCountdown(userState);
                                }
                            }
                        }
                    } else {
                        console.error('Failed to check queue status:', response.status);
                    }
                } catch (error) {
                    console.error('Queue monitoring error:', error);
                }
            }, 10000); // æ¯10ç§’æ£€æŸ¥ä¸€æ¬¡æ’é˜ŸçŠ¶æ€
        }

        // ğŸ”§ æ–°å¢ï¼šStop queue status monitoring
        function stopQueueMonitoring() {
            const currentUserState = getCurrentUserState();
            if (!currentUserState) return;

            if (currentUserState.queueMonitorInterval) {
                clearInterval(currentUserState.queueMonitorInterval);
                currentUserState.queueMonitorInterval = null;
                console.log('Stop queue status monitoring');
            }
        }

        // ğŸ”§ æ–°å¢ï¼šå¯åŠ¨ç­‰å¾…å€’è®¡æ—¶åŠŸèƒ½
        function startWaitingCountdown(userState) {
            if (!userState) return;

            // å¦‚æœå·²ç»åœ¨å€’è®¡æ—¶ä¸­ï¼Œä¸è¦é‡å¤å¯åŠ¨
            if (userState.waitingCountdown) {
                return;
            }

            console.log('Start resource wait countdown');

            // è®¾ç½®å€’è®¡æ—¶æ—¶é—´ï¼ˆ60ç§’ï¼‰
            let countdownSeconds = 60;
            userState.waitingCountdown = true;

            const countdownInterval = setInterval(() => {
                countdownSeconds--;

                // æ›´æ–°é˜Ÿåˆ—ä¿¡æ¯æ˜¾ç¤ºï¼Œæ˜¾ç¤ºå€’è®¡æ—¶
                updateQueueInfo({
                    queue_position: `Waiting (${countdownSeconds}s)`,
                    total_waiting: 'Resource temporarily unavailable, retrying soon.'
                });

                // å€’è®¡æ—¶ç»“æŸ
                if (countdownSeconds <= 0) {
                    clearInterval(countdownInterval);
                    userState.waitingCountdown = false;

                    // è‡ªåŠ¨é‡è¯•æ¿€æ´»ç¯å¢ƒ
                    console.log('Countdown finished, automatically retrying activation.');
                    addMessage('assistant', 'â° Wait time expired, retrying activation automatically...', 'status');

                    // å°è¯•è‡ªåŠ¨é‡æ–°æ¿€æ´»
                    autoRetryActivation();
                }
            }, 1000);

            // å°†å®šæ—¶å™¨å­˜å‚¨åˆ°å¯¹è¯çŠ¶æ€ä¸­ï¼Œä»¥ä¾¿éœ€è¦æ—¶æ¸…ç†
            userState.waitingCountdownInterval = countdownInterval;
        }

        // ğŸ”§ æ–°å¢ï¼šåœæ­¢ç­‰å¾…å€’è®¡æ—¶
        function stopWaitingCountdown(userState) {
            if (!userState || !userState.waitingCountdown) return;

            if (userState.waitingCountdownInterval) {
                clearInterval(userState.waitingCountdownInterval);
                userState.waitingCountdownInterval = null;
            }
            userState.waitingCountdown = false;
            console.log('Stop resource wait countdown.');
        }

        // ğŸ”§ æ–°å¢ï¼šè‡ªåŠ¨é‡è¯•æ¿€æ´»åŠŸèƒ½
        async function autoRetryActivation() {
            try {
                const currentUserState = getCurrentUserState();
                if (!currentUserState) return;

                // æ£€æŸ¥å½“å‰æ˜¯å¦å·²ç»æ¿€æ´»æˆ–æ­£åœ¨è¿è¡Œä»»åŠ¡
                if (currentUserState.isActivated || currentUserState.isTaskRunning) {
                    console.log('Environment already active or task running; skipping auto-retry.');
                    return;
                }

                // ğŸ”§ æ–°å¢ï¼šè®¾ç½®æ­£åœ¨æ¿€æ´»çŠ¶æ€
                updateCurrentUserState({ isActivating: true });

                // ä½¿ç”¨è®¾å¤‡é€‰æ‹©ä¸‹æ‹‰æ¡†çš„å½“å‰å€¼
                const selectedSandboxType = document.getElementById('deviceSelect').value;

                // æ„å»ºe2e_infoå‚æ•°
                const e2eInfo = buildE2eInfo();
                const extraParams = getExtraParams();

                const config = {
                    mode: isPhoneSandboxType(selectedSandboxType) ? 'phone_use' : 'pc_use',
                    sandbox_type: selectedSandboxType,
                    max_steps: parseInt(document.getElementById('maxStepsInput').value),
                    pc_use_addon_info: document.getElementById('addonInfoInput').value,
<!--                    timeout: 120,-->
                    user_id: userId,
                    chat_id: chatId,
                    e2e_info: e2eInfo,
                    extra_params: extraParams
                };

                const response = await fetch(`${getBackendUrl()}/cua/init`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        config: config
                    })
                });

                if (response.status === 200) {
                    const result = await response.json();
                    updateCurrentUserState({
                        isActivated: true,
                        isActivating: false // ğŸ”§ æ¿€æ´»æˆåŠŸï¼Œæ¸…é™¤æ¿€æ´»ä¸­çŠ¶æ€
                    });
                    updateSandboxTypeState(config.sandbox_type);

                    // åœæ­¢æ’é˜Ÿç›‘æ§
                    stopQueueMonitoring();
                    stopWaitingCountdown(currentUserState);

                    // æ›´æ–°çŠ¶æ€
                    updateSandboxPreview(result);

                    // æ˜¾ç¤ºæ¿€æ´»æˆåŠŸæ¶ˆæ¯
                    addMessage('assistant', 'ğŸ‰ Auto-retry succeeded! Environment is active!', 'status');

                    // å¯ç”¨ä»»åŠ¡è¾“å…¥
                    document.getElementById('taskInput').disabled = false;
                    document.getElementById('sendBtn').disabled = false;

                    // ç¦ç”¨è®¾å¤‡é€‰æ‹©
                    const deviceSelect = document.getElementById('deviceSelect');
                    deviceSelect.classList.add('device-select-disabled');
                    deviceSelect.disabled = true;

                    // éšè—æ’é˜Ÿä¿¡æ¯
                    const queueInfoContainer = document.getElementById('queueInfoContainer');
                    if (queueInfoContainer) {
                        queueInfoContainer.style.display = 'none';
                    }

                    // å¯åŠ¨å¿ƒè·³
                    startHeartbeat();

                    // å¯åŠ¨å€’è®¡æ—¶
                    startCountdown();

                    // æ›´æ–°æ¿€æ´»æŒ‰é’®çŠ¶æ€ä¸ºæˆåŠŸå¹¶ç½®ç°
                    const activateBtn = document.getElementById('activateBtn');
                    if (activateBtn) {
                        activateBtn.innerHTML = '<i class="fas fa-check"></i> Activation Complete';
                        activateBtn.disabled = true;
                        activateBtn.classList.add('btn-disabled');
                    }

                } else if (response.status === 429) {
                    // ä»ç„¶è¿›å…¥æ’é˜ŸçŠ¶æ€ï¼Œç»§ç»­ç­‰å¾…
                    const errorDetail = await response.json();
                    if (errorDetail.detail && errorDetail.detail.type === 'queued') {
                        updateCurrentUserState({
                            isQueued: true,
                            isActivating: false, // ğŸ”§ è¿›å…¥æ’é˜Ÿï¼Œæ¸…é™¤æ¿€æ´»ä¸­çŠ¶æ€
                            queueInfo: errorDetail.detail
                        });
                        updateQueueInfo(errorDetail.detail);

                        addMessage('assistant', `â³ Auto-retry queued, continuing to wait...`, 'status');

                        // ç»§ç»­ç›‘æ§æ’é˜ŸçŠ¶æ€
                        if (!getCurrentUserState().queueMonitorInterval) {
                            startQueueMonitoring();
                        }
                    } else {
                        // å¦‚æœèµ„æºä»ç„¶ä¸å¯ç”¨ï¼Œé‡æ–°å¼€å§‹å€’è®¡æ—¶
                        updateCurrentUserState({ isActivating: false }); // ğŸ”§ æ¸…é™¤æ¿€æ´»ä¸­çŠ¶æ€
                        addMessage('assistant', 'â° Resource still unavailable, retrying again in 60 seconds...', 'status');
                        startWaitingCountdown(currentUserState);
                    }
                } else {
                    // å…¶ä»–é”™è¯¯ï¼Œé‡æ–°å¼€å§‹å€’è®¡æ—¶
                    updateCurrentUserState({ isActivating: false }); // ğŸ”§ æ¸…é™¤æ¿€æ´»ä¸­çŠ¶æ€
                    console.log('Auto-retry failed, status code:', response.status);
                    addMessage('assistant', 'âš ï¸ Auto-retry failed, retrying again in 60 seconds...', 'status');
                    startWaitingCountdown(currentUserState);
                }

            } catch (error) {
                updateCurrentUserState({ isActivating: false }); // ğŸ”§ å¼‚å¸¸æ—¶æ¸…é™¤æ¿€æ´»ä¸­çŠ¶æ€
                console.error('Error during auto-retry activation:', error);
                addMessage('assistant', `âš ï¸ Auto-retry error: ${error.message}, retrying again in 60 seconds...`, 'status');

                // å‡ºé”™æ—¶ä¹Ÿé‡æ–°å¼€å§‹å€’è®¡æ—¶
                const currentUserState = getCurrentUserState();
                if (currentUserState) {
                    startWaitingCountdown(currentUserState);
                }
            }
        }

        // å¤„ç†SSEæ¶ˆæ¯
        function handleSSEMessage(data) {
            const currentUserState = getCurrentUserState();
            if (!currentUserState) return;

            // è¿‡æ»¤å…¶å®ƒä»»åŠ¡æˆ–å…¶å®ƒå¯¹è¯çš„æ¨é€
            if (data.task_id && data.task_id !== currentUserState.taskId){
                return;           // å¿½ç•¥
            }

            const dataType = (data.type || '').toString().toLowerCase();
            const normalizedStage = (data.stage || '').toString().toLowerCase();

            // å¦‚æœæ˜¯å¿ƒè·³æ¶ˆæ¯ï¼Œç›´æ¥è¿”å›
            if (data.type === 'heartbeat') {
                return;
            }

            // ğŸ”§ æ–°å¢ï¼šå¤„ç†ä»»åŠ¡å¼€å§‹çŠ¶æ€
            if (data.status === 'starting' || data.status === 'running') {
                if (currentUserState && !currentUserState.isTaskRunning) {
                    console.log('Task started, setting isTaskRunning to true.');
                    updateCurrentUserState({ isTaskRunning: true, all_subtasks_complete_handled: false });
                }
            }

            // ğŸ”§ æ–°å¢ï¼šå¤„ç†èµ„æºå¯ç”¨é€šçŸ¥
            if (data.status === 'resource_available') {
                console.log("Received resource-ready notification, retrying activation automatically.");
                addMessage('assistant', 'âœ… Resources ready! Re-activating environment automatically...', 'status');

                // ğŸ”§ æ–°å¢ï¼šåœæ­¢æ’é˜Ÿç›‘æ§
                stopQueueMonitoring();

                // ğŸ”§ æ–°å¢ï¼šåœæ­¢ç­‰å¾…å€’è®¡æ—¶
                if (currentUserState) {
                    stopWaitingCountdown(currentUserState);
                }

                // æ¸…é™¤æ’é˜ŸçŠ¶æ€
                updateCurrentUserState({ isQueued: false });
                const queueInfoContainer = document.getElementById('queueInfoContainer');
                if (queueInfoContainer) {
                    queueInfoContainer.style.display = 'none';
                }

                // è‡ªåŠ¨é‡æ–°å°è¯•æ¿€æ´»ç¯å¢ƒ
                setTimeout(autoReactivateEnvironment, 1000);
                return;
            }

            const msgId = data.uuid || `${data.type}_${data.status}_${data.timestamp}`;

            // æ£€æŸ¥æ¶ˆæ¯æ˜¯å¦å·²å¤„ç†è¿‡
            if (currentUserState.processedMessages.has(msgId)) {
                return;
            }

            currentUserState.processedMessages.add(msgId);

            // é˜²æ­¢processedMessagesé›†åˆè¿‡å¤§ï¼Œå®šæœŸæ¸…ç†
            if (currentUserState.processedMessages.size > 1000) {
                const recentMessages = Array.from(currentUserState.processedMessages).slice(-500);
                currentUserState.processedMessages = new Set(recentMessages);
            }

            // ç‰¹åˆ«å¤„ç†é”™è¯¯æ¶ˆæ¯ï¼Œç¡®ä¿é”™è¯¯ä¿¡æ¯è¢«æ˜¾ç¤º
            if (data.status === 'error') {
                // ç›´æ¥æ˜¾ç¤ºé”™è¯¯æ¶ˆæ¯ï¼Œæ— è®ºæ¶ˆæ¯ç±»å‹æ˜¯ä»€ä¹ˆ
                const errorMessage = data.message || (data.data && data.data.message) || 'Unknown error';
                addMessage('assistant', `âŒ Task execution error: ${errorMessage}`, 'status');

                // åœæ­¢ç›‘æ§å¹¶æ›´æ–°çŠ¶æ€
                stopSSEMonitoring();
                updateCurrentUserState({ isTaskRunning: false });
                resetTaskState();

                // éšè—åœæ­¢æŒ‰é’®
                const stopTaskBtn = document.getElementById('stopTaskBtn');
                if (stopTaskBtn) {
                    stopTaskBtn.style.display = 'none';
                    stopTaskBtn.disabled = false;
                    stopTaskBtn.innerHTML = '<i class="fas fa-stop"></i> Stop Task';
                }
                return;
            }

            if (dataType === 'step') {
                // ç‰¹æ®Šå¤„ç†ï¼šå¦‚æœSTEPæ¶ˆæ¯åŒ…å«statusä¸ºerrorçš„ä¿¡æ¯ï¼Œç›´æ¥æ˜¾ç¤ºé”™è¯¯
                if (data.status === 'error' && data.message) {
                    addMessage('assistant', `âŒ Task execution error: ${data.message}`, 'status');
                } else {
                    formatStepMessage(data);
                }
            } else if (dataType === 'analysis_stage') {
                // å¤„ç†åˆ†æé˜¶æ®µæ¶ˆæ¯
                formatAnalysisStageMessage(data);
            } else if (['plan', 'planner', 'planner_result', 'plan_result', 'planner_steps'].includes(dataType)) {
                handlePlannerContent(data.data || data);
            } else {
                formatStatusMessage(data);
            }

            // æ£€æŸ¥ä»»åŠ¡æ˜¯å¦çœŸçš„åœ¨è¿è¡Œä¸­ï¼Œé¿å…è¯¯åˆ¤åˆå§‹çŠ¶æ€æ¶ˆæ¯
            // currentUserState already declared at the beginning of this function

            // ç‰¹æ®Šå¤„ç†ï¼šåªæœ‰å½“ä»»åŠ¡ç¡®å®åœ¨è¿è¡Œæ—¶ï¼Œæ‰å¤„ç†è¿™äº›DoneçŠ¶æ€
            if (currentUserState && currentUserState.isTaskRunning && !currentUserState.all_subtasks_complete_handled) {
                // å¦‚æœæ”¶åˆ°IDLEçŠ¶æ€ä¸”æ¶ˆæ¯æ˜¯"Ready to start"ï¼Œè¯´æ˜ä»»åŠ¡å·²Done
                if (data.status === 'idle' && data.message && data.message.toLowerCase().includes('ready to start')) {
                    stopSSEMonitoring();
                    updateCurrentUserState({ isTaskRunning: false, all_subtasks_complete_handled: true });
                    resetTaskState();
                    addMessage('assistant', 'âœ… Task executed successfully', 'status');
                    return;
                }

                // æ·»åŠ å¯¹"Task stopped, resources still allocated"çŠ¶æ€çš„å¤„ç†
                if (data.status === 'idle' && data.message && data.message.toLowerCase().includes('task stopped, resources still allocated')) {
                    stopSSEMonitoring();
                    updateCurrentUserState({ isTaskRunning: false, all_subtasks_complete_handled: true });
                    resetTaskState();
                    addMessage('assistant', 'âœ… Task executed successfully', 'status');
                    return;
                }

                // ğŸ”§ æ–°å¢ï¼šæ·»åŠ å¯¹æ‰‹åŠ¨åœæ­¢ä»»åŠ¡çš„å¤„ç†
                if (data.status === 'idle' && data.message && data.message.toLowerCase().includes('task stopped')) {
                  stopSSEMonitoring();
                  updateCurrentUserState({ isTaskRunning: false, all_subtasks_complete_handled: true });
                  resetTaskState();
                  addMessage('assistant', 'â¹ï¸ Task stopped', 'status');

                  // é‡æ–°å¯ç”¨åœæ­¢æŒ‰é’®å¹¶æ¢å¤å…¶çŠ¶æ€
                  const stopTaskBtn = document.getElementById('stopTaskBtn');
                  if (stopTaskBtn) {
                      stopTaskBtn.style.display = 'none';
                      stopTaskBtn.disabled = false;
                      stopTaskBtn.innerHTML = '<i class="fas fa-stop"></i> Stop Task';
                  }
                  return;
                }
            }


            // å¤„ç†stageçº§åˆ«çš„ç»“æŸçŠ¶æ€
            if (['all_completed', 'plan_completed', 'plan_cancelled', 'plan_canceled', 'limit_completed', 'canceled'].includes(normalizedStage)) {
                stopSSEMonitoring();
                updateCurrentUserState({ isTaskRunning: false, all_subtasks_complete_handled: true });

                const completionText =
                    data.text ||
                    data.message ||
                    (normalizedStage === 'limit_completed'
                        ? 'âš ï¸ Reached maximum step limit.'
                        : normalizedStage === 'canceled' || normalizedStage === 'plan_cancelled' || normalizedStage === 'plan_canceled'
                            ? 'â¹ï¸ Task stopped'
                            : 'âœ… Task completed');

                addMessage('assistant', completionText, 'status');
                resetTaskState();

                const stopTaskBtn = document.getElementById('stopTaskBtn');
                if (stopTaskBtn) {
                    stopTaskBtn.style.display = 'none';
                    stopTaskBtn.disabled = false;
                    stopTaskBtn.innerHTML = '<i class="fas fa-stop"></i> Stop Task';
                }

                return;
            }

            // æ”¶åˆ°å…¶ä»–ç»“æŸæ€ä¹Ÿåœæ­¢ç›‘æ§
            if (['completed', 'stopped'].includes(data.status)) {
                stopSSEMonitoring();
                updateCurrentUserState({ isTaskRunning: false, all_subtasks_complete_handled: true });
                const endMessage = data.status === 'completed' ? 'âœ… Task completed' : 'â¹ï¸ Task stopped';
                addMessage('assistant', endMessage, 'status');
                resetTaskState();

                // åœ¨è¿™é‡Œé‡æ–°å¯ç”¨åœæ­¢æŒ‰é’®å¹¶æ¢å¤å…¶çŠ¶æ€
                const stopTaskBtn = document.getElementById('stopTaskBtn');
                if (stopTaskBtn) {
                    stopTaskBtn.style.display = 'none';
                    stopTaskBtn.disabled = false;
                    stopTaskBtn.innerHTML = '<i class="fas fa-stop"></i> Stop Task';
                }

                return;
            }

            // æ·»åŠ å¯¹human_helpçŠ¶æ€çš„å¤„ç†
            if (data.type === 'STEP' && data.data && data.data.human_help_status) {
                showHumanInterventionNotice(data.data);
            }

            // å¦‚æœæ²¡æœ‰ä»»ä½•çŠ¶æ€æ›´æ–°ï¼Œæ·»åŠ ä¸€æ¡é»˜è®¤æ¶ˆæ¯
            if (!data.type && !data.status) {
                console.warn('Received message in unknown format:', data);
            }
        }

        // ğŸ”§ æ–°å¢ï¼šè‡ªåŠ¨é‡æ–°æ¿€æ´»ç¯å¢ƒï¼ˆæ”¶åˆ°èµ„æºå¯ç”¨é€šçŸ¥åè°ƒç”¨ï¼‰
        async function autoReactivateEnvironment() {
            const currentUserState = getCurrentUserState();
            if (!currentUserState || currentUserState.isActivated) {
                console.log("Session state invalid or environment already active; skipping auto-activation.");
                return;
            }

            const activateBtn = document.getElementById('activateBtn');
            if (!activateBtn) {
                console.log("Activation button not found; skipping auto-activation.");
                return;
            }

            console.log("Starting automatic reactivation.");

            // ğŸ”§ æ–°å¢ï¼šåœæ­¢æ’é˜Ÿç›‘æ§å¹¶æ¸…é™¤æ’é˜ŸçŠ¶æ€
            stopQueueMonitoring();
            updateCurrentUserState({ isQueued: false });
            const queueInfoContainer = document.getElementById('queueInfoContainer');
            if (queueInfoContainer) {
                queueInfoContainer.style.display = 'none';
            }

            // æ›´æ–°æŒ‰é’®çŠ¶æ€
            activateBtn.disabled = true;
            activateBtn.classList.add('btn-disabled');
            activateBtn.innerHTML = '<span class="loading-spinner"></span> Auto-activating...';

            try {
                // ä½¿ç”¨è®¾å¤‡é€‰æ‹©ä¸‹æ‹‰æ¡†çš„å½“å‰å€¼
                const selectedSandboxType = document.getElementById('deviceSelect').value;

                // æ„å»ºe2e_infoå‚æ•°
                const e2eInfo = buildE2eInfo();
                const extraParams = getExtraParams();

                const config = {
                    mode: isPhoneSandboxType(selectedSandboxType) ? 'phone_use' : 'pc_use',
                    sandbox_type: selectedSandboxType,
                    max_steps: parseInt(document.getElementById('maxStepsInput').value),
                    pc_use_addon_info: document.getElementById('addonInfoInput').value,
<!--                    timeout: 120,-->
                    user_id: userId,
                    chat_id: chatId,
                    e2e_info: e2eInfo,
                    extra_params: extraParams
                };

                const response = await fetch(`${getBackendUrl()}/cua/init`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        config: config
                    })
                });

                if (response.status === 200) {
                    const result = await response.json();
                    updateCurrentUserState({
                        isActivated: true
                    });
                    updateSandboxTypeState(config.sandbox_type);

                    // æ›´æ–°çŠ¶æ€
                    updateSandboxPreview(result);

                    // æ˜¾ç¤ºæ¿€æ´»æˆåŠŸæ¶ˆæ¯
                    addMessage('assistant', 'ğŸ‰ Environment auto-activation successful! Ready to use!', 'status');

                    // å¯ç”¨ä»»åŠ¡è¾“å…¥
                    document.getElementById('taskInput').disabled = false;
                    document.getElementById('sendBtn').disabled = false;

                    // ç¦ç”¨è®¾å¤‡é€‰æ‹©
                    const deviceSelect = document.getElementById('deviceSelect');
                    deviceSelect.classList.add('device-select-disabled');
                    deviceSelect.disabled = true;

                    // å¯åŠ¨å¿ƒè·³
                    startHeartbeat();

                    // å¯åŠ¨å€’è®¡æ—¶
                    startCountdown();

                    // æ›´æ–°æ¿€æ´»æŒ‰é’®çŠ¶æ€ä¸ºæˆåŠŸå¹¶ç½®ç°
                    activateBtn.innerHTML = '<i class="fas fa-check"></i> Activation Complete';

                } else {
                    // è‡ªåŠ¨æ¿€æ´»å¤±è´¥ï¼Œæ¢å¤æŒ‰é’®çŠ¶æ€è®©å¯¹è¯æ‰‹åŠ¨é‡è¯•
                    console.log("Auto-activation failed, status code:", response.status);
                    addMessage('assistant', 'âš ï¸ Auto-activation failed, please click Activate Environment to retry.', 'status');

                    activateBtn.disabled = false;
                    activateBtn.classList.remove('btn-disabled');
                    activateBtn.innerHTML = '<i class="fas fa-bolt"></i> Activate Environment';
                }

            } catch (error) {
                console.error("Auto-activation error:", error);
                addMessage('assistant', `âš ï¸ Auto-activation error: ${error.message}, please retry manually.`, 'status');

                // æ¢å¤æŒ‰é’®çŠ¶æ€
                activateBtn.disabled = false;
                activateBtn.classList.remove('btn-disabled');
                activateBtn.innerHTML = '<i class="fas fa-bolt"></i> Activate Environment';
            }
        }

        // æ ¼å¼åŒ–æ­¥éª¤æ¶ˆæ¯
        function formatStepMessage(statusData) {
            const stepData = statusData.data || {};
            const stepNum = stepData.step || '?';
            const observation = stepData.observation || '';
            const actionParsed = stepData.action_parsed || '';
            const actionExecuted = stepData.action_executed || '';
            const thought = stepData.thought || '';
            const auxiliaryInfo = stepData.auxiliary_info || {};
            // è·å–è®¾å¤‡ID
            const equipmentId = stepData.equipment_id || '';

            // ç”Ÿæˆæ­¥éª¤çš„å”¯ä¸€æ ‡è¯†ç¬¦
            // const stepKey = `task_${statusData.task_id || 'unknown'}_step_${stepNum}_time_${statusData.timestamp || ''}`;
            const stepKey = `task_${statusData.task_id || 'unknown'}_step_${stepNum}_time_${statusData.timestamp || ''}_uuid_${statusData.uuid || ''}`;


            // æ„å»ºæ¶ˆæ¯å†…å®¹
            let messageParts = [`ğŸ” **Step ${stepNum}** - ${statusData.timestamp || ''}`];

            if (auxiliaryInfo.request_id) {
                messageParts.push(`ğŸ“ **Request ID**\n${auxiliaryInfo.request_id}`);
            }

            if (auxiliaryInfo.session_id) {
                messageParts.push(`ğŸ“ **Session ID**\n${auxiliaryInfo.session_id}`);
            }

            // æ˜¾ç¤ºè®¾å¤‡ID
            if (equipmentId) {
                messageParts.push(`ğŸ–¥ï¸ **Device ID**\n${equipmentId}`);
            }

            // è§£æobservationä¸ºJSONæ ¼å¼å¹¶ç¾è§‚åœ°æ˜¾ç¤º
            if (observation) {
                try {
                    const observationData = JSON.parse(observation);

                    // æ„å»ºç¾è§‚çš„æ˜¾ç¤ºæ ¼å¼
                    let observationParts = [];

                    if (observationData.thought) {
                        observationParts.push(`ğŸ’­ **Model reasoning**\n${observationData.thought}`);
                    }

                    if (observationData.action) {
                        observationParts.push(`âš¡ **Action**\n${observationData.action}`);
                    }

                    if (observationData.action_params) {
                        // ç¾åŒ–åŠ¨ä½œå‚æ•°æ˜¾ç¤º
                        const params = observationData.action_params;
                        observationParts.push(`ğŸ“‹ **Action parameters**\n${params}`);
                    }

                    if (observationData.explanation) {
                        observationParts.push(`ğŸ’¡ **Execution notes**\n${observationData.explanation}`);
                    }

                    if (observationParts.length > 0) {
                        messageParts.push(observationParts.join('\n\n'));
                    }

                    // å¤„ç†æ ‡æ³¨å›¾ç‰‡
                    if (observationData.annotated_img_path) {
                        messageParts.push(`ğŸ“ **Annotated screenshot**\n<img src="${observationData.annotated_img_path}" alt="Annotated Screenshot" style="max-width: 100%; height: auto; border: 1px solid #ddd; border-radius: 4px; margin-top: 5px;">`);
                    }

                } catch (e) {
                    // å¦‚æœä¸æ˜¯JSONæ ¼å¼ï¼ŒæŒ‰åŸæ¥çš„æ–¹å¼å¤„ç†
                    messageParts.push(`ğŸ” **Reasoning**\n${observation}`);
                }
            }

            // å¤„ç†auxiliaryInfoä¸­çš„æˆªå›¾ï¼ˆå‘åå…¼å®¹ï¼‰
            if (auxiliaryInfo.annotated_img_path && !observation.includes('annotated_img_path')) {
                messageParts.push(`ğŸ“ **Screenshot info**\n<img src="${auxiliaryInfo.annotated_img_path}" alt="Annotated Screenshot" style="max-width: 100%; height: auto; border: 1px solid #ddd; border-radius: 4px; margin-top: 5px;">`);
            }

            if (actionParsed) {
                messageParts.push(`âš¡ **Action**\n${actionParsed}`);
            }

            if (actionExecuted) {
                messageParts.push(`âœ… **Executed**\n${actionExecuted}`);
            }

            const content = messageParts.join('\n\n');

            // æ›´æ–°æˆ–æ·»åŠ æ­¥éª¤æ¶ˆæ¯
            updateOrAddStepMessage(content, stepKey);

            // å¤„ç†æˆªå›¾URL
            if (stepData.screenshot_url) {
                updateScreenshot(stepData.screenshot_url);
            }
        }

        // æ ¼å¼åŒ–åˆ†æé˜¶æ®µæ¶ˆæ¯
        function formatAnalysisStageMessage(statusData) {
            console.log('[DEBUG] formatAnalysisStageMessage called with:', statusData);
            const stageData = statusData.data || {};
            const stage = stageData.stage || '';
            const message = stageData.text || '';
            console.log('[DEBUG] Extracted stage:', stage, 'message:', message);

            // é˜¶æ®µå›¾æ ‡å’Œä¸­æ–‡ç¿»è¯‘æ˜ å°„
            const stageConfig = {
                'screenshot': {
                    icon: 'ğŸ“¸',
                    name: 'Screenshot capture',
                    messages: {
                        'capturing': 'Capturing screenshot...',
                        'completed': 'Screenshot captured.'
                    }
                },
                'ai_analysis': {
                    icon: 'ğŸ§ ',
                    name: 'AI analysis',
                    messages: {
                        'analyzing': 'Calling the AI model to analyze the screenshot...',
                        'completed': 'AI analysis complete.'
                    }
                },
                'image_processing': {
                    icon: 'ğŸ–¼ï¸',
                    name: 'Image processing',
                    messages: {
                        'processing': 'Processing image annotations and coordinates...',
                        'completed': 'Image processing complete.'
                    }
                },
                'completed': {
                    icon: 'âœ…',
                    name: 'Done',
                    messages: {
                        'completed': 'Screenshot analysis complete, ready to execute actions.'
                    }
                }
            };

            const config = stageConfig[stage] || {
                icon: 'âš™ï¸',
                name: stage,
                messages: { [message]: message }
            };

            const icon = config.icon;
            const stageName = config.name;
            const translatedMessage = config.messages[message] || message;
            const stageKey = `analysis_stage_${stage}`;

            // æ„å»ºé˜¶æ®µæ˜¾ç¤ºå†…å®¹
            const content = `${icon} **${stageName}**: ${translatedMessage}`;

            // æ›´æ–°æˆ–æ·»åŠ é˜¶æ®µæ¶ˆæ¯
            updateOrAddAnalysisStageMessage(content, stageKey, stage, message);
        }

        // æ›´æ–°æˆ–æ·»åŠ åˆ†æé˜¶æ®µæ¶ˆæ¯
        function updateOrAddAnalysisStageMessage(content, stageKey, stage, message) {
            console.log('[DEBUG] updateOrAddAnalysisStageMessage called with stage:', stage, 'message:', message);
            const currentUserState = getCurrentUserState();
            if (!currentUserState) {
                console.error('[DEBUG] No current user state found, aborting analysis stage message update');
                return;
            }
            console.log('[DEBUG] Current user state exists, proceeding with message update');

            // å¦‚æœæ˜¯æ–°çš„åˆ†æå¼€å§‹ï¼ˆscreenshoté˜¶æ®µï¼‰ï¼Œæ¸…ç†ä¹‹å‰çš„åˆ†æé˜¶æ®µæ¶ˆæ¯
            if (stage === 'screenshot' && message === 'capturing') {
                currentUserState.messages = currentUserState.messages.filter(msg =>
                    msg.type !== 'analysis_stages'
                );
            }

            // æŸ¥æ‰¾æ˜¯å¦å·²ç»å­˜åœ¨åˆ†æé˜¶æ®µçš„æ¶ˆæ¯å®¹å™¨
            let analysisMessageIndex = currentUserState.messages.findIndex(msg =>
                msg.type === 'analysis_stages'
            );

            if (analysisMessageIndex === -1) {
                // åˆ›å»ºæ–°çš„åˆ†æé˜¶æ®µæ¶ˆæ¯å®¹å™¨
                const analysisMessageObj = {
                    role: 'assistant',
                    content: createAnalysisStagesHTML(),
                    type: 'analysis_stages',
                    stages: {}
                };
                currentUserState.messages.push(analysisMessageObj);
                analysisMessageIndex = currentUserState.messages.length - 1;
            }

            // æ›´æ–°é˜¶æ®µçŠ¶æ€ï¼šå½“å‰é˜¶æ®µDoneç”±ä¸‹ä¸€é˜¶æ®µå¼€å§‹åˆ¤å®šï¼Œè¿™é‡Œä»…è®°å½•å†…å®¹
            const analysisMessage = currentUserState.messages[analysisMessageIndex];
            analysisMessage.stages[stage] = {
                content: content,
                completed: stage === 'completed'
            };

            // å½“ä¸€ä¸ªæ–°é˜¶æ®µå¼€å§‹æ—¶ï¼Œè‡ªåŠ¨æŠŠå‰ä¸€ä¸ªé˜¶æ®µæ ‡è®°ä¸ºDone
            const order = ['screenshot', 'ai_analysis', 'image_processing'];
            const currentIdx = order.indexOf(stage);

            // ç‰¹æ®Šå¤„ç†ï¼šå½“æ”¶åˆ° 'completed' é˜¶æ®µæ—¶ï¼Œæ ‡è®°æ‰€æœ‰é˜¶æ®µä¸ºDone
            if (stage === 'completed') {
                console.log('[DEBUG] Processing completed stage, marking all stages as completed');
                // æ ‡è®°æ‰€æœ‰é˜¶æ®µä¸ºDone
                order.forEach(stageId => {
                    if (analysisMessage.stages[stageId]) {
                        analysisMessage.stages[stageId].completed = true;
                        console.log(`[DEBUG] Marked ${stageId} as completed`);
                    }
                });
                // ğŸ”§ ä¿®å¤ï¼šè®¾ç½®æ•´ä½“DoneçŠ¶æ€ï¼Œè§¦å‘Doneè§†å›¾
                analysisMessage.stages.completed = true;
                console.log('[DEBUG] Set overall completion state');
                console.log('[DEBUG] Final stages state:', analysisMessage.stages);
            } else if (currentIdx > 0) {
                // æ™®é€šé€»è¾‘ï¼šæ–°é˜¶æ®µå¼€å§‹æ—¶ï¼Œå‰ä¸€ä¸ªé˜¶æ®µæ ‡è®°ä¸ºDone
                const prevStage = order[currentIdx - 1];
                if (analysisMessage.stages[prevStage]) {
                    analysisMessage.stages[prevStage].completed = true;
                }
            }

            // é‡æ–°ç”ŸæˆHTMLå†…å®¹
            analysisMessage.content = createAnalysisStagesHTML(analysisMessage.stages);

            renderMessages();
        }

        // åˆ›å»ºåˆ†æé˜¶æ®µçš„HTML
        function createAnalysisStagesHTML(stages = {}) {
            const stageOrder = ['screenshot', 'ai_analysis', 'image_processing'];
            const stageNames = {
                'screenshot': 'Screenshot capture',
                'ai_analysis': 'AI analysis',
                'image_processing': 'Image processing'
            };

            // å¦‚æœåˆ†æå·²Doneï¼Œæ˜¾ç¤ºç®€æ´çš„DoneçŠ¶æ€
            if (stages.completed) {
                console.log('[DEBUG] Creating completed analysis HTML - stages.completed exists:', stages.completed);
                return '<div class="analysis-stages-container completed-analysis">' +
                       '<div class="analysis-completed-message">' +
                      'âœ… <strong>Screenshot analysis complete</strong> - Ready to execute.' +
                       '</div>' +
                       '</div>';
            }

            console.log('[DEBUG] Creating progress analysis HTML - stages:', stages);

            let html = '<div class="analysis-stages-container">';
            html += '<div class="analysis-stages-title">ğŸ“Š <strong>Screenshot Analysis Progress</strong></div>';
            html += '<div class="analysis-stages-list">';

            stageOrder.forEach((stageId, index) => {
                const stage = stages[stageId];
                const isActive = stage && !stage.completed;
                const isCompleted = stage && stage.completed;

                let stageClass = 'analysis-stage';
                let stageIcon = '';

                if (isCompleted) {
                    stageClass += ' completed';
                    stageIcon = 'âœ…';
                } else if (isActive) {
                    stageClass += ' active';
                    stageIcon = 'ğŸ”„';
                } else {
                    stageClass += ' waiting';
                    stageIcon = 'â³';
                }

                html += `<div class="${stageClass}">`;
                html += `<span class="stage-icon">${stageIcon}</span>`;
                html += `<span class="stage-name">${stageNames[stageId]}</span>`;
                if (stage && stage.content) {
                    html += `<div class="stage-content">${stage.content}</div>`;
                }
                html += '</div>';
            });

            html += '</div></div>';
            return html;
        }

        // æ ¼å¼åŒ–çŠ¶æ€æ¶ˆæ¯
        function formatStatusMessage(statusData) {
            const status = statusData.status || '';
            const message = statusData.message || '';

            // çŠ¶æ€å›¾æ ‡æ˜ å°„
            const statusIcons = {
                'starting': 'ğŸ”„',
                'running': 'âš¡',
                'completed': 'âœ…',
                'error': 'âŒ',
                'stopped': 'â¹ï¸',
                'idle': 'â¸ï¸'
            };

            const icon = statusIcons[status] || 'ğŸ“‹';
            const formattedMessage = `${icon} **${status.toUpperCase()}**: ${message}`;

            addMessage('assistant', formattedMessage, 'status');
        }

        // æ›´æ–°æˆ–æ·»åŠ æ­¥éª¤æ¶ˆæ¯
        function updateOrAddStepMessage(content, stepKey) {
            const currentUserState = getCurrentUserState();
            if (!currentUserState) return;

            // æŸ¥æ‰¾æ˜¯å¦å·²ç»å­˜åœ¨ç›¸åŒæ­¥éª¤çš„æ¶ˆæ¯
            const existingMessageIndex = currentUserState.messages.findIndex(msg =>
                msg.type === 'status' && msg.stepKey === stepKey
            );

            const messageObj = {
                role: 'assistant',
                content: content,
                type: 'status',
                stepKey: stepKey
            };

            if (existingMessageIndex !== -1) {
                // æ›´æ–°ç°æœ‰æ¶ˆæ¯
                currentUserState.messages[existingMessageIndex] = messageObj;
            } else {
                // æ·»åŠ æ–°æ¶ˆæ¯
                currentUserState.messages.push(messageObj);
            }

            renderMessages();
        }

        // æ›´æ–°æ²™ç›’é¢„è§ˆ
        function updateSandboxPreview(data) {
            const previewContainer = document.getElementById('previewContainer');
            // æ£€æŸ¥å…ƒç´ æ˜¯å¦å­˜åœ¨
            if (!previewContainer) {
                console.error('Preview container not found');
                return;
            }

            if (data.sandbox_url) {
                previewContainer.innerHTML = `
                    <div class="iframe-container" id="sandboxIframeContainer">
                        <iframe id="sandboxIframe" src="${data.sandbox_url}" onload="handleIframeLoad(this)" onerror="handleIframeError(this)"></iframe>
                        <div class="iframe-error-message" style="display: none; padding: 20px; text-align: center; color: #666;">
                            <p>æ— æ³•åœ¨ iframe ä¸­æ˜¾ç¤ºæ­¤å†…å®¹</p>
                            <button onclick="openInNewTab('${data.sandbox_url}')" class="btn btn-primary">åœ¨æ–°æ ‡ç­¾é¡µä¸­æ‰“å¼€</button>
                        </div>
                    </div>
                `;
            } else if (data.equipment_web_url && data.equipment_web_sdk_info) {
                // æ„é€ å¸¦å‚æ•°çš„URL
                const sdkInfoJson = encodeURIComponent(JSON.stringify(data.equipment_web_sdk_info));
                const webUrl = `${data.equipment_web_url}?sdk_info=${sdkInfoJson}`;

                previewContainer.innerHTML = `
                    <div class="iframe-container" id="sandboxIframeContainer">
                        <iframe id="sandboxIframe" src="${webUrl}" onload="handleIframeLoad(this)" onerror="handleIframeError(this)"></iframe>
                        <div class="iframe-error-message" style="display: none; padding: 20px; text-align: center; color: #666;">
                            <p>æ— æ³•åœ¨ iframe ä¸­æ˜¾ç¤ºæ­¤å†…å®¹</p>
                            <button onclick="openInNewTab('${webUrl}')" class="btn btn-primary">åœ¨æ–°æ ‡ç­¾é¡µä¸­æ‰“å¼€</button>
                        </div>
                    </div>
                `;
            } else if (data.equipment_screenshot_url) {
                previewContainer.innerHTML = `
                    <div class="screenshot-container">
                        <img src="${data.equipment_screenshot_url}" alt="Device screenshot" onerror="this.onerror=null; this.src='data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"400\" height=\"300\" viewBox=\"0 0 400 300\"><rect width=\"400\" height=\"300\" fill=\"%23f8f9fa\"/><text x=\"50%\" y=\"50%\" font-family=\"Arial\" font-size=\"20\" fill=\"%236c757d\" text-anchor=\"middle\" dy=\".3em\">Device screenshot failed to load</text></svg>';">
                        <p class="text-muted mt-2">Device screenshot</p>
                    </div>
                `;
            } else {
                // é»˜è®¤æ˜¾ç¤º
                previewContainer.innerHTML = `
                    <div class="text-center text-muted">
                        <i class="fas fa-desktop fa-3x mb-3"></i>
                        <h5>ç­‰å¾…Sandboxå¯åŠ¨</h5>
                        <p class="mb-0">Enter a task on the left to start the Computer Use Agent.</p>
                    </div>
                `;
            }
        }

        // è¿›å…¥/é€€å‡ºå…¨å±
        function togglePreviewFullscreen() {
            const container = document.getElementById('sandboxIframeContainer');
            if (!container) return;
            if (!document.fullscreenElement) {
                if (container.requestFullscreen) container.requestFullscreen();
            } else {
                if (document.exitFullscreen) document.exitFullscreen();
            }
        }

        // ç»‘å®šå…¨å±æŒ‰é’®ä¸çª—å£å˜åŒ–
        window.addEventListener('DOMContentLoaded', () => {
            const btn = document.getElementById('fullscreenToggleBtn');
            if (btn) btn.addEventListener('click', togglePreviewFullscreen);
            document.addEventListener('fullscreenchange', () => {
                const icon = document.querySelector('#fullscreenToggleBtn i');
                if (icon) {
                    icon.classList.toggle('fa-compress', !!document.fullscreenElement);
                    icon.classList.toggle('fa-expand', !document.fullscreenElement);
                }
            });
        });

        // å¤„ç† iframe åŠ è½½æˆåŠŸ
        function handleIframeLoad(iframe) {
            // éšè—é”™è¯¯æ¶ˆæ¯
            const errorMessage = iframe.parentNode.querySelector('.iframe-error-message');
            if (errorMessage) {
                errorMessage.style.display = 'none';
            }
            iframe.style.display = 'block';
        }

        // å¤„ç† iframe åŠ è½½é”™è¯¯
        function handleIframeError(iframe) {
            // æ˜¾ç¤ºé”™è¯¯æ¶ˆæ¯å¹¶éšè— iframe
            iframe.style.display = 'none';
            const errorMessage = iframe.parentNode.querySelector('.iframe-error-message');
            if (errorMessage) {
                errorMessage.style.display = 'block';
            }
        }


        // æ›´æ–°æˆªå›¾
        function updateScreenshot(screenshotUrl) {
            const previewContainer = document.getElementById('previewContainer');
            if (previewContainer && screenshotUrl) {
                previewContainer.innerHTML = `                    <div class="screenshot-container">
                        <img src="${screenshotUrl}" alt="Device screenshot" onerror="this.onerror=null; this.src='data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"400\" height=\"300\" viewBox=\"0 0 400 300\"><rect width=\"400\" height=\"300\" fill=\"%23f8f9fa\"/><text x=\"50%\" y=\"50%\" font-family=\"Arial\" font-size=\"20\" fill=\"%236c757d\" text-anchor=\"middle\" dy=\".3em\">Device screenshot failed to load</text></svg>';">
                        <p class="text-muted mt-2">Device screenshot</p>
                    </div>
                `;
            }
        }

        // æ›´æ–°é˜Ÿåˆ—ä¿¡æ¯
        function updateQueueInfo(queueInfo) {
            const queuePosition = document.getElementById('queuePosition');
            const totalWaiting = document.getElementById('totalWaiting');
            const queueInfoContainer = document.getElementById('queueInfoContainer');

            // æ£€æŸ¥å…ƒç´ æ˜¯å¦å­˜åœ¨
            if (queuePosition && totalWaiting && queueInfoContainer) {
                queuePosition.textContent = queueInfo.queue_position || 0;
                totalWaiting.textContent = queueInfo.total_waiting || 0;
                queueInfoContainer.style.display = 'block';
            }
        }

        // æ·»åŠ æ¶ˆæ¯åˆ°èŠå¤©ç•Œé¢
        function addMessage(role, content, type = '') {
            const currentUserState = getCurrentUserState();
            if (!currentUserState) return;

            currentUserState.messages.push({
                role: role,
                content: content,
                type: type
            });

            renderMessages();
        }

        // æ¸²æŸ“æ¶ˆæ¯
        function renderMessages() {
            const currentUserState = getCurrentUserState();
            if (!currentUserState) return;

            const chatContainer = document.getElementById('chatContainer');
            const welcomeMessage = document.getElementById('welcomeMessage');

            // æ£€æŸ¥å…ƒç´ æ˜¯å¦å­˜åœ¨
            if (!chatContainer) {
                console.error('Chat container not found');
                return;
            }

            // å¦‚æœæœ‰æ¶ˆæ¯ï¼Œéšè—æ¬¢è¿ä¿¡æ¯
            if (welcomeMessage) {
                if (currentUserState.messages.length > 0) {
                    welcomeMessage.style.display = 'none';
                } else {
                    welcomeMessage.style.display = 'block';
                }
            }

            // æ¸…ç©ºèŠå¤©å®¹å™¨
            chatContainer.innerHTML = '';

            // æ·»åŠ æ‰€æœ‰æ¶ˆæ¯
            currentUserState.messages.forEach(msg => {
                const messageDiv = document.createElement('div');
                messageDiv.className = `message ${msg.role === 'user' ? 'user-message' : 'assistant-message'} ${msg.type === 'status' ? 'status-message' : ''} ${msg.stepKey ? 'step-message' : ''}`;

                if (msg.role === 'user') {
                    messageDiv.innerHTML = `
                        <div><strong>ğŸ‘¤ Me</strong></div>
                        <div>${msg.content}</div>
                    `;
                } else {
                    // å¤„ç†Markdownæ ¼å¼
                    const formattedContent = msg.content
                        .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                        .replace(/\n/g, '<br>');

                    messageDiv.innerHTML = `
                        <div><strong>ğŸ¤– Assistant</strong></div>
                        <div>${formattedContent}</div>
                    `;
                }

                chatContainer.appendChild(messageDiv);
            });

            // æ»šåŠ¨åˆ°åº•éƒ¨
            chatContainer.scrollTop = chatContainer.scrollHeight;
        }

        // æ¸…ç©ºèŠå¤©
        function clearChat() {
            const currentUserState = getCurrentUserState();
            if (!currentUserState) return;

            currentUserState.messages = [];
            renderMessages();
        }

        // é‡ç½®ä»»åŠ¡çŠ¶æ€ - é€‚é…æ–°çš„æµå¼æ¥å£
        function resetTaskState() {
            const currentUserState = getCurrentUserState();
            if (!currentUserState) return;

            updateCurrentUserState({
                isTaskRunning: false,
                isQueued: false,
                processedMessages: new Set(),
                all_subtasks_complete_handled: false
            });

            // åœæ­¢æ’é˜Ÿç›‘æ§
            stopQueueMonitoring();

            // åœæ­¢ç­‰å¾…å€’è®¡æ—¶
            stopWaitingCountdown(currentUserState);

            const taskInput = document.getElementById('taskInput');
            const sendBtn = document.getElementById('sendBtn');
            const stopTaskBtn = document.getElementById('stopTaskBtn');
            const queueInfoContainer = document.getElementById('queueInfoContainer');

            // ç›´æ¥è§£é”è¾“å…¥å’Œå‘é€æŒ‰é’®
            if (taskInput) taskInput.disabled = false;
            if (sendBtn) {
                sendBtn.disabled = false;
                sendBtn.innerHTML = '<i class="fas fa-check"></i> Completed';
                setTimeout(() => {
                    const state = getCurrentUserState();
                    if (state && !state.isTaskRunning) {
                        sendBtn.innerHTML = '<i class="fas fa-paper-plane"></i> Send';
                    }
                }, 2000);
            }
            if (stopTaskBtn) {
                stopTaskBtn.style.display = 'none';
                stopTaskBtn.disabled = false;
                stopTaskBtn.innerHTML = '<i class="fas fa-stop"></i> Stop Task';
            }

            if (queueInfoContainer) {
                queueInfoContainer.style.display = 'none';
            }

            console.log('Task state reset (streaming version)');
        }

        // å¯åŠ¨å¿ƒè·³
        function startHeartbeat() {
            if (heartbeatInterval) {
                clearInterval(heartbeatInterval);
            }

            heartbeatInterval = setInterval(async () => {
                try {
                    const response = await fetch(`${getBackendUrl()}/cua/heartbeat?user_id=${userId}&chat_id=${chatId}`, {
                        method: 'GET'
                    });

                    if (response.ok) {
                        const result = await response.json();

                        // ğŸ”§ æ–°å¢ï¼šæ£€æŸ¥ä¼šè¯å¤±æ•ˆçŠ¶æ€
                        if (result.status === 'chat_inactive' || result.error_code === 'CHAT_INACTIVE') {
                            console.warn('âš ï¸ Session has expired:', result.message);

                            // åœæ­¢å¿ƒè·³
                            stopHeartbeat();

                            // å…³é—­å³ä¾§ç”»é¢ï¼ˆè®¾å¤‡é¢„è§ˆï¼‰
                            const previewContainer = document.getElementById('previewContainer');
                            if (previewContainer) {
                                // é‡ç½®ä¸ºåˆå§‹çŠ¶æ€
                                previewContainer.innerHTML = `
                                    <div class="text-center text-muted">
                                        <i class="fas fa-desktop fa-3x mb-3"></i>
                                        <h5>ç­‰å¾…Sandboxå¯åŠ¨</h5>
                                        <p class="mb-0">Enter a task on the left to start the Computer Use Agent.</p>
                                    </div>
                                `;
                            }

                            // ğŸ”§ æ–°å¢ï¼šé‡ç½®å·¦ä¾§èŠå¤©ç•Œé¢
                            const chatContainer = document.getElementById('chatContainer');
                            if (chatContainer) {
                                // é‡ç½®ä¸ºåˆå§‹æ¬¢è¿æ¶ˆæ¯
                                chatContainer.innerHTML = `
                                    <div class="text-center text-muted py-5" id="welcomeMessage">
                                        <i class="fas fa-hand-wave fa-2x mb-3"></i>
                                        <h5>æ¬¢è¿ä½¿ç”¨Computer Use Agentï¼</h5>
                                        <p class="mb-0">Enter the task you want to run below.</p>
                                        <p class="mb-0">ç¤ºä¾‹ä»»åŠ¡ï¼šuse the web browser to get the current weather in Hangzhou via Bing Search</p>
                                    </div>
                                `;
                            }

                            // ğŸ”§ æ–°å¢ï¼šé‡ç½®è¾“å…¥æ¡†å’ŒæŒ‰é’®çŠ¶æ€
                            const taskInput = document.getElementById('taskInput');
                            const sendBtn = document.getElementById('sendBtn');
                            if (taskInput) {
                                taskInput.value = '';
                                taskInput.disabled = true;
                                taskInput.placeholder = 'Activate the environment before entering a task...';
                            }
                            if (sendBtn) {
                                sendBtn.disabled = true;
                                sendBtn.innerHTML = '<i class="fas fa-paper-plane"></i> Send';
                            }

                            // é‡ç½®æ¿€æ´»æŒ‰é’®çŠ¶æ€
                            const activateBtn = document.getElementById('activateBtn');
                            if (activateBtn) {
                                activateBtn.innerHTML = '<i class="fas fa-bolt"></i> Activate Environment';
                                activateBtn.disabled = false;
                                activateBtn.classList.remove('btn-disabled');
                            }

                            // é‡ç½®ç”¨æˆ·çŠ¶æ€
                            updateCurrentUserState({
                                isActivated: false,
                                isActivating: false,
                                isTaskRunning: false,
                                currentSandboxType: null,
                                taskId: null
                            });

                            // å¯ç”¨è®¾å¤‡é€‰æ‹©
                            const deviceSelect = document.getElementById('deviceSelect');
                            if (deviceSelect) {
                                deviceSelect.classList.remove('device-select-disabled');
                                deviceSelect.disabled = false;
                            }

                            // åœæ­¢å€’è®¡æ—¶
                            stopCountdown();

                            // æ˜¾ç¤ºä¼šè¯å¤±æ•ˆæç¤º
                            addMessage('assistant', `âš ï¸ Session has expired: ${result.message}`, 'status');
                            if (result.active_chat_id) {
                                addMessage('assistant', `ğŸ”„ Active session: ${result.active_chat_id}`, 'status');
                            }

                            return; // åœæ­¢ç»§ç»­å¤„ç†å¿ƒè·³
                        }

                        // ğŸ”§ æ­£å¸¸å¿ƒè·³å“åº”å¤„ç†
                        if (result.success && result.is_active_chat) {
                            // ä¼šè¯æ­£å¸¸ï¼Œé™é»˜å¤„ç†
                            console.log('ğŸ’“ Heartbeat healthy');
                        } else {
                            console.warn('âš ï¸ Heartbeat issue:', result);
                        }
                    } else {
                        console.error('âŒ Heartbeat request failed:', response.status, response.statusText);
                    }
                } catch (error) {
                    console.error('âŒ Heartbeat send failed:', error);
                }
            }, 5000); // æ¯5ç§’å‘é€ä¸€æ¬¡å¿ƒè·³
        }

        // åœæ­¢å¿ƒè·³
        function stopHeartbeat() {
            if (heartbeatInterval) {
                clearInterval(heartbeatInterval);
                heartbeatInterval = null;
            }
        }

        // ğŸ”§ æ–°å¢ï¼šåœæ­¢å€’è®¡æ—¶
        function stopCountdown() {
            if (countdownInterval) {
                clearInterval(countdownInterval);
                countdownInterval = null;
            }
            // éšè—å€’è®¡æ—¶å®¹å™¨
            const countdownContainer = document.getElementById('countdownContainer');
            if (countdownContainer) {
                countdownContainer.style.display = 'none';
            }
        }

        // å¯åŠ¨å€’è®¡æ—¶
        function startCountdown() {
            const currentUserState = getCurrentUserState();
            if (!currentUserState) return;

            updateCurrentUserState({ countdownStartTime: Date.now() });
            const countdownContainer = document.getElementById('countdownContainer');

            if (countdownContainer) {
                countdownContainer.style.display = 'block';
            }

            if (countdownInterval) {
                clearInterval(countdownInterval);
            }

            countdownInterval = setInterval(() => {
                const currentUserState = getCurrentUserState();
                if (!currentUserState || !currentUserState.countdownStartTime) {
                    clearInterval(countdownInterval);
                    return;
                }

                const elapsed = (Date.now() - currentUserState.countdownStartTime) / 1000;
                const remaining = Math.max(0, 60 * 60 - elapsed);

                const minutes = Math.floor(remaining / 60);
                const seconds = Math.floor(remaining % 60);

                const countdownText = document.getElementById('countdownText');
                if (countdownText) {
                    countdownText.textContent =
                        remaining <= 0 ? 'â³ Time is up!' : `â³ Remaining: ${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                }

                // æ ¹æ®å‰©ä½™æ—¶é—´æ”¹å˜èƒŒæ™¯è‰²
                if (countdownContainer) {
                    if (remaining <= 0) {
                        countdownContainer.style.backgroundColor = '#dc3545'; // çº¢è‰²
                    } else if (remaining < 5 * 60) {
                        countdownContainer.style.backgroundColor = '#fd7e14'; // æ©™è‰²
                    } else {
                        countdownContainer.style.backgroundColor = '#dc3545'; // çº¢è‰²
                    }
                }

                // å€’è®¡æ—¶ç»“æŸæ—¶è‡ªåŠ¨åœæ­¢ä»»åŠ¡
                if (remaining <= 0) {
                    clearInterval(countdownInterval);
                    handleCountdownEnd();
                }
            }, 1000);
        }

        // Quick command presets
        const phonePresets = [
            'Open the Maps app on the phone and search for coffee shops nearby.',
            'Take a screenshot on the phone and share it to the gallery.',
            'Open the phone browser and check the latest weather forecast.',
            'Compose a new message on the phone that says â€œI will arrive in 10 minutesâ€.',
            'Open the calendar app on the phone and add an event for tomorrow 9am.'
        ];
        const pcPresets    = [
            'Open Firefox and search for the latest Alibaba stock price, then copy the record to the spreadsheet.',
            'Create a blank presentation in WPS and add a title slide that says â€œProject Overviewâ€.',
            'Open WPS Writer and draft a short introduction about Alibaba with the text in blue.',
            'Change the Windows system theme to light mode.'
        ];

        /* 2. æ¸²æŸ“æŒ‰é’® */
        function renderQuickCommands () {
            const container = document.getElementById('quickCmdContainer');
            if (!container) return;

            // æ ¹æ®å½“å‰è®¾å¤‡é€‰æ‹©åˆ‡æ¢æ¨¡æ¿
            const device = document.getElementById('deviceSelect').value;
            const presets = device.includes('phone') ? phonePresets : pcPresets;

            // æ¸…ç©ºæ—§æŒ‰é’®
            container.innerHTML = '';

            // é€ä¸ªåˆ›å»º
            presets.forEach(txt => {
                const span = document.createElement('span');
                span.className = 'quick-cmd-btn';
                span.textContent = txt;

                // ç‚¹å‡»åæŠŠæ–‡æœ¬å†™å…¥è¾“å…¥æ¡†ï¼ˆå¯é€‰æ‹© append æˆ–è¦†ç›–ï¼‰
                span.onclick = () => {
                    const input = document.getElementById('taskInput');
                    input.value = txt;      // å¦‚æœæƒ³åœ¨æœ«å°¾è¿½åŠ å¯æ”¹æˆï¼šinput.value += txt;
                    input.focus();
                };

                container.appendChild(span);
            });
        }

        /* 3. åˆå§‹åŒ–æ—¶ä¸è®¾å¤‡åˆ‡æ¢æ—¶éƒ½è°ƒç”¨ä¸€æ¬¡ */
        document.addEventListener('DOMContentLoaded', () => {
            renderQuickCommands();          // é¦–æ¬¡æ¸²æŸ“
        });
        // æ·»åŠ æ–‡å­—ç»“æŸ-cjj



        // å¤„ç†å€’è®¡æ—¶ç»“æŸ
        async function handleCountdownEnd() {
            const currentUserState = getCurrentUserState();
            if (!currentUserState) return;

            // å¦‚æœä»»åŠ¡ä»åœ¨è¿è¡Œï¼Œå…ˆåœæ­¢ä»»åŠ¡
            if (currentUserState.isTaskRunning) {
                try {
                    await fetch(`${getBackendUrl()}/cua/stop?user_id=${userId}&chat_id=${chatId}`, {
                        method: 'GET'
                    });
                } catch (error) {
                    console.error('Failed to stop task:', error);
                }
            }

            // è°ƒç”¨åç«¯é‡Šæ”¾èµ„æºæ¥å£
            try {
                await fetch(`${getBackendUrl()}/cua/release`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        user_id: userId,
                        chat_id: chatId
                    })
                });
            } catch (error) {
                console.error('Failed to release resources:', error);
            }

            // é‡ç½®çŠ¶æ€
            const countdownContainer = document.getElementById('countdownContainer');
            if (countdownContainer) {
                countdownContainer.style.display = 'none';
            }

            stopHeartbeat();
            stopSSEMonitoring();
            resetTaskState();
            updateCurrentUserState({ isActivated: false });

            const taskInput = document.getElementById('taskInput');
            const sendBtn = document.getElementById('sendBtn');
            if (taskInput) {
                taskInput.disabled = true;
            }
            if (sendBtn) {
                sendBtn.disabled = true;
            }

            // é‡æ–°å¯ç”¨è®¾å¤‡é€‰æ‹©
            const deviceSelect = document.getElementById('deviceSelect');
            if (deviceSelect) {
                deviceSelect.classList.remove('device-select-disabled');
                deviceSelect.disabled = false;
            }

            // é‡ç½®é¢„è§ˆåŒºåŸŸ
            const previewContainer = document.getElementById('previewContainer');
            if (previewContainer) {
                previewContainer.innerHTML = `
                    <div class="text-center text-muted">
                        <i class="fas fa-desktop fa-3x mb-3"></i>
                        <h5>ç­‰å¾…Sandboxå¯åŠ¨</h5>
                        <p class="mb-0">Enter a task on the left to start the Computer Use Agent.</p>
                    </div>
                `;
            }
        }

        // è·å–åç«¯URL
        function getBackendUrl() {
            // æ£€æŸ¥æ˜¯å¦åœ¨ ModelScope ç¯å¢ƒä¸­
            const currentOrigin = window.location.origin;
            console.log("Current origin:", currentOrigin); // è°ƒè¯•ä¿¡æ¯

            // åœ¨ ModelScope ä¸Šï¼Œæ‰€æœ‰è¯·æ±‚éƒ½é€šè¿‡ 7860 ç«¯å£ï¼Œåç«¯è¯·æ±‚é€šè¿‡ /backend/ è·¯å¾„
            if (currentOrigin.includes('pai-eas.aliyuncs.com') ||
                currentOrigin.includes('modelscope') ||
                currentOrigin.includes(':7860') ||
                // ä¸ºé­”æ­éƒ¨ç½²ç¯å¢ƒæ·»åŠ åˆ¤æ–­
                (!currentOrigin.includes('localhost') && !currentOrigin.includes('127.0.0.1'))) {
                return currentOrigin + '/backend';
            }

            // æœ¬åœ°å¼€å‘ç¯å¢ƒ
            return currentOrigin.replace(':8001', ':8002');
<!--            return "https://mcp-commtnysdmv-xcdaadoqnh.cn-hangzhou.fcapp.run"-->
        }

        // è·å–åŸºç¡€URLï¼ˆé™æ€èµ„æºURLï¼‰
        function getBaseUrl() {
            return window.location.origin + '/';
        }

        // æ˜¾ç¤ºäººç±»å¹²é¢„æ¨¡æ€æ¡†
        function showHumanInterventionNotice(stepData) {
            // åœ¨èŠå¤©æ¡†ä¸‹æ–¹æ˜¾ç¤ºæé†’æ¶ˆæ¯
            const noticeHtml = `                <div class="alert alert-warning alert-dismissible fade show mt-3" role="alert" id="humanInterventionNotice">
                    <div>
                        <div class="d-flex justify-content-between align-items-start">
                            <div>
                                <i class="fas fa-exclamation-triangle fa-lg"></i>
                                <strong class="ms-2">éœ€è¦äººå·¥å¹²é¢„</strong>
                            </div>
                            <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
                        </div>
                        <div class="mt-3">
                            <p class="mb-2">Please complete the following steps:</p>
                            <p class="mb-3 bg-light p-2 rounded">${stepData.action_executed || 'Please complete the required steps'}</p>
                            <div class="d-flex justify-content-end">
                                <button type="button" class="btn btn-primary" id="humanInterventionContinueBtn">
                                    <i class="fas fa-play"></i> ç»§ç»­ä»»åŠ¡
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            `;

            // ç§»é™¤å·²å­˜åœ¨çš„æé†’
            const existingNotice = document.getElementById('humanInterventionNotice');
            if (existingNotice) {
                existingNotice.remove();
            }

            // æ’å…¥åˆ°èŠå¤©æ¡†ä¸‹æ–¹
            const chatContainer = document.getElementById('chatContainer');
            const inputGroup = chatContainer.nextElementSibling;
            if (inputGroup && inputGroup.classList.contains('input-group')) {
                inputGroup.insertAdjacentHTML('afterend', noticeHtml);

                // ç»‘å®šç»§ç»­æŒ‰é’®äº‹ä»¶
                document.getElementById('humanInterventionContinueBtn').onclick = function() {
                    continueTask();
                    // ç§»é™¤æé†’
                    const notice = document.getElementById('humanInterventionNotice');
                    if (notice) {
                        notice.remove();
                    }
                };
            }
        }

        // ç»§ç»­ä»»åŠ¡
        async function continueTask() {
            try {
                const response = await fetch(`${getBackendUrl()}/cua/interrupt_wait?user_id=${userId}&chat_id=${chatId}`, {
                    method: 'GET'
                });

                if (response.status === 200) {
                    addMessage('assistant', 'âœ… The system has been notified to continue.', 'status');
                } else if (response.status === 401 || response.status === 403) {
                    const errorData = await response.json();
                    showErrorMessage(`Permission error: ${errorData.detail || 'Login expired, please sign in again'}`);
                    addMessage('assistant', `âŒ Permission error: ${errorData.detail || 'Login expired, please sign in again'}`, 'status');
                } else {
                    const errorText = await response.text();
                    showErrorMessage(`Failed to resume task: HTTP ${response.status}`);
                    addMessage('assistant', `âŒ Failed to resume task: HTTP ${response.status}\n${errorText}`, 'status');
                }
            } catch (error) {
                showErrorMessage(`Error while resuming task: ${error.message}`);
                addMessage('assistant', `âŒ Error while resuming task: ${error.message}`, 'status');
            }
        }
    </script>
</body>
</html>
