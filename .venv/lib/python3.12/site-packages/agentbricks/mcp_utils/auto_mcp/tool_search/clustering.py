# -*- coding: utf-8 -*-
"""
Clustering and directory splitting logic
"""

import json
import logging
from typing import Set, Dict, Any, List
from jsonschema import validate
import numpy as np
from .tree import Node, Tree

logger = logging.getLogger(__name__)


class ClusteringManager:
    """Clustering manager"""

    def __init__(self, tree_instance: Tree):
        self.tree = tree_instance

    async def cluster_nodes_llm(
        self,
        nodes: Set[Node],
        schema: Dict[str, Any],
        system_prompt: str,
        user_prompt: str,
    ) -> Set[Node]:
        """Use LLM to cluster nodes into multiple groups

        Args:
            nodes: Set of nodes to cluster
            schema: JSON Schema for validating LLM response
            system_prompt: System prompt template
            user_prompt: User prompt template

        Returns:
            New set of clustered nodes, grouping nodes,
            returns original nodes if clustering fails
        """
        # Build node descriptions
        nodes_descriptions = ""
        for node in nodes:
            nodes_descriptions += f"{node}\n"

        # Build prompts
        messages = [
            {
                "role": "system",
                "content": system_prompt.format(
                    max_items=self.tree.max_items_per_node,
                    json_schema=schema,
                ),
            },
            {
                "role": "user",
                "content": user_prompt.format(
                    max_items=self.tree.max_items_per_node,
                    nodes_descriptions=nodes_descriptions,
                ),
            },
        ]

        # Try to get LLM clustering results
        count = 3
        while count > 0:
            try:
                ans_cont = await self.tree.ask_llm_async(
                    messages=messages,
                    response_format={
                        "type": "json_schema",
                        "json_schema": {"name": "response", "schema": schema},
                        "strict": True,
                    },
                )
                ans: dict = json.loads(ans_cont)  # dict
                validate(instance=ans, schema=schema)
                break
            except Exception as e:
                print(f"LLM clustering attempt {4 - count}/3 failed: {e}")
                count -= 1
                if count == 0:
                    # When last attempt fails, return original node set
                    print("LLM clustering failed, returning original node set")
                    return nodes

        # Process clustering results
        children = set()
        parsed_child = set()

        if not ans:
            logger.warning("LLM returned empty clustering results")
            return nodes

        logger.info(f"LLM returned {len(ans)} clusters")

        for cluster_name in ans:
            cluster = ans[cluster_name]
            children_node = set()
            for child in cluster["children"]:
                node = self.tree.get_node_by_name(child)
                if node is not None and node in nodes:
                    children_node.add(node)

            # Create new group node
            if len(children_node) <= 1:
                logger.info(
                    f"Cluster '{cluster_name}' only has {len(children_node)} "
                    "nodes, skipping creation",
                )
                parsed_child.update(children_node)
                children.update(children_node)
                continue

            parsed_child.update(children_node)  # Inserted nodes

            node = self._add_tree_node(
                cluster["details"],
                cluster_name,
                children_node,
            )
            children.add(node)

        # Add any ungrouped nodes
        unprocessed_nodes = nodes.difference(parsed_child)
        if unprocessed_nodes:
            logger.info(f"Adding {len(unprocessed_nodes)} ungrouped nodes")
        for child in unprocessed_nodes:
            children.add(child)

        logger.info(
            f"Clustering complete, output {len(children)} nodes",
        )
        return children

    def _add_tree_node(
        self,
        cluster_details: str,
        cluster_name: str,
        children: Set[Node],
    ) -> Node:
        """Add new tree node as a group

        Args:
            cluster_details: Group description
            cluster_name: Group name
            children: Set of child nodes

        Returns:
            Newly created node
        """
        if not self.tree._name_to_node.get(cluster_name):
            node = Node(
                name=cluster_name,
                description=cluster_details,
                is_directory=True,
            )

            # Add embedding vector
            emb = self.tree.get_embedding(node.name)
            if emb is not None and len(self.tree.tree_node) < len(
                self.tree.tree_emb,
            ):
                self.tree.tree_emb[len(self.tree.tree_node)] = emb

            self.tree.tree_node.append(node.name)
            self.tree._name_to_node[cluster_name] = node
        else:
            node = self.tree._name_to_node[cluster_name]

        # Add child nodes
        for child in children:
            if child:
                self.tree.add_child(child, node)

        return node
