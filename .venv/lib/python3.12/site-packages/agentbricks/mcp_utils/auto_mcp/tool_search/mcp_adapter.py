# -*- coding: utf-8 -*-
"""
MCP Server Adapter - Compatibility layer for using MCPServerStdio
instead of MCPConnector
"""

from typing import List, Dict, Any, Optional
from agentbricks.mcp_utils.server import MCPServerStdio, MCPServerStdioParams
import logging

logger = logging.getLogger(__name__)


class MCPAdapter:
    """
    Adapter class to replace MCPConnector
    with MCPServerStdio functionality
    Maintains API compatibility while providing enhanced features
    """

    def __init__(self) -> None:
        self.server: Optional[MCPServerStdio] = None
        self._connected = False

    async def connect(self, server_script_path: str) -> bool:
        """Connect to MCP server using script path

        Args:
            server_script_path: MCP server script path

        Returns:
            Whether connection was successful
        """
        try:
            # Check script type
            is_python = server_script_path.endswith(".py")
            is_js = server_script_path.endswith(".js")
            if not (is_python or is_js):
                raise ValueError("Server script must be .py or .js file")

            # Choose execution command based on script type
            command = "python" if is_python else "node"

            # Create server configuration
            params: MCPServerStdioParams = {
                "command": command,
                "args": [server_script_path],
            }

            # Create and connect to server
            self.server = MCPServerStdio(
                params=params,
                cache_tools_list=True,  # Enable caching for better performance
                name=f"tool_search_server_{server_script_path}",
            )

            # Connect using async context manager
            await self.server.connect()
            self._connected = True

            logger.info(
                f"Successfully connected to MCP server: {server_script_path}",
            )
            return True

        except Exception as e:
            logger.error(f"Failed to connect to MCP server: {e}")
            self._connected = False
            return False

    async def get_tools(self) -> List[Dict[str, Any]]:
        """Get list of available tools from server

        Returns:
            List of tools
        """
        if not self.server or not self._connected:
            raise RuntimeError(
                "Not connected to MCP server, please call connect() first",
            )

        try:
            # Get tools using the enhanced server
            mcp_tools = await self.server.list_tools()

            # Convert to the expected format
            tools = []
            for tool in mcp_tools:
                tool_data = {
                    "name": tool.name,
                    "description": tool.description,
                    "input_schema": tool.inputSchema,
                    "type": "function",
                }
                tools.append(tool_data)

            logger.info(f"Retrieved {len(tools)} tools from server")
            return tools

        except Exception as e:
            logger.error(f"Failed to get tools: {e}")
            return []

    async def call_tool(
        self,
        tool_name: str,
        arguments: Optional[Dict[str, Any]] = None,
    ) -> Any:
        """Call a tool on the server (new functionality not in
        original MCPConnector)

        Args:
            tool_name: Name of the tool to call
            arguments: Arguments to pass to the tool

        Returns:
            Tool execution result
        """
        if not self.server or not self._connected:
            raise RuntimeError(
                "Not connected to MCP server, please call connect() first",
            )

        try:
            result = await self.server.call_tool(tool_name, arguments)
            logger.info(f"Successfully called tool: {tool_name}")
            return result
        except Exception as e:
            logger.error(f"Failed to call tool {tool_name}: {e}")
            raise

    def invalidate_cache(self) -> None:
        """Invalidate the tools cache (new functionality)"""
        if self.server:
            self.server.invalidate_tools_cache()
            logger.info("Tools cache invalidated")

    @property
    def is_connected(self) -> bool:
        """Check if adapter is connected to server"""
        return self._connected and self.server is not None

    @property
    def server_name(self) -> str:
        """Get server name"""
        return self.server.name if self.server else "Not connected"

    async def cleanup(self) -> None:
        """Clean up resources"""
        try:
            if self.server:
                await self.server.cleanup()
                logger.info("MCP server cleanup completed")
        except Exception as e:
            logger.error(f"Error during cleanup: {e}")
        finally:
            self._connected = False
            self.server = None


# For backward compatibility, alias the adapter as MCPConnector
MCPConnector = MCPAdapter
