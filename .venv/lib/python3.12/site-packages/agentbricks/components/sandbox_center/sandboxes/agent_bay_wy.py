# -*- coding: utf-8 -*-
import os
import logging
import time
import json
import base64
import requests
from agentbay import AgentBay, Session
from agentbay.exceptions import AgentBayError
from agentbay.session_params import CreateSessionParams
from agentbricks.components.sandbox_center.sandboxes.sandbox_base import (
    SandboxBase,
    OperationStatus,
)
from typing import Callable, Any, List, Tuple
from agentbricks.components.sandbox_center.utils.utils import (
    download_oss_image_and_save_return_base64,
)
from agentbricks.components.sandbox_center.utils.oss_client import OSSClient
from pydantic import BaseModel
from agentbricks.utils.logger_util import logger

execute_wait_time_: int = 5


class AgentBayPhoneWy:
    def __init__(
        self,
        image_id: str = "mobile-use-android-12",
        session_id: str = None,
    ):
        self.agent_bay_instance = AgentBayPhoneWyInstance(
            image_id=image_id,
            session_id=session_id,
        )

    def run_command(
        self,
        command: str,
        background: bool = False,
        timeout: int = 5,
        ope_type: str = None,
    ) -> str:
        try:
            status, res = self.agent_bay_instance.run_command(command)
            return f"The run command {status} :{res}"
        except Exception as e:
            # self.agent_bay_session.clean_session()
            logger.info(f"get_screenshot_oss_url failed:{e}")

        return "failed"

    def go_home(self, action: str) -> str:
        self.agent_bay_instance.home("home")
        return f"This {action} has been done"

    def press_key(
        self,
        key: str = None,
        key_combination: list[str] = None,
        ope_type: str = None,
    ) -> str:
        return OperationStatus.DEVICE_UN_SUPPORTED_OPERATION.value

    def long_press(self, x: int, y: int, press_time: str) -> str:
        status, res = self.agent_bay_instance.long_press(x, y, press_time)
        return f"The key has been pressed.{status},{res}"

    def type_text(self, text: str, ope_type: str = None) -> str:
        self.agent_bay_instance.type(text)
        return "Input text has been pressed."

    def click_element(
        self,
        query: str,
        click_command: Callable,
        action_name: str = "click",
    ) -> str:
        return OperationStatus.DEVICE_UN_SUPPORTED.value

    def click(
        self,
        x: int = 0,
        y: int = 0,
        count: int = 1,
        query: str = "",
        action_name: str = "click",
        ope_type: str = None,
        x2: int = 0,
        y2: int = 0,
        width: int = 0,
        height: int = 0,
    ) -> str:
        status, res = self.agent_bay_instance.tab__(
            x,
            y,
            x2,
            y2,
            width,
            height,
        )
        return f"The mouse has clicked  at ({x}, {y},{x2}, {y2}).{status}"

    def right_click(
        self,
        x: int,
        y: int,
        count: int = 1,
        ope_type: str = None,
    ) -> str:
        return OperationStatus.DEVICE_UN_SUPPORTED_OPERATION.value

    def click_and_type(
        self,
        x: int,
        y: int,
        text: str,
        ope_type: str = None,
    ) -> str:
        self.agent_bay_instance.click_and_type(x, y, text)
        return f"The text '{text}' has been typed."

    def append_text(
        self,
        x: int,
        y: int,
        text: str,
        ope_type: str = None,
    ) -> str:
        return OperationStatus.DEVICE_UN_SUPPORTED_OPERATION.value

    def launch_app(self, app: str, ope_type: str = None) -> str:
        return OperationStatus.DEVICE_UN_SUPPORTED_OPERATION.value

    def slide(self, x1: int, y1: int, x2: int, y2: int) -> str:
        return self.agent_bay_instance.slide(x1, y1, x2, y2)

    def back(self, action: str) -> str:
        self.agent_bay_instance.back("back")
        return f"This {action} has been done"

    def menu(self, action: str) -> str:
        self.agent_bay_instance.menu("menu")
        return f"This {action} has been done"

    def enter(self, action: str) -> str:
        self.agent_bay_instance.enter("enter")
        return "Enter key pressed."

    def kill_front_app(self, action: str) -> str:
        status, res = self.agent_bay_instance.kill_the_front_app(action)
        return f"This {action} has been done {status}"

    def execute_wait_time_set(self, execute_wait_time: int = 5) -> str:
        return OperationStatus.DEVICE_UN_SUPPORTED_OPERATION.value

    def get_screenshot_oss_url(self, max_retry: int = 2) -> str:
        try:
            for _ in range(max_retry):
                url = self.agent_bay_instance.get_screenshot_oss_url()
                if url:
                    return url
        except Exception as e:
            # self.agent_bay_session.clean_session()
            logger.log(
                level=logging.ERROR,
                msg=f"get_screenshot_oss_url failed:{e}",
            )

        return "Error"


class AgentBayPhoneWyInstance:
    def __init__(
        self,
        image_id: str = "mobile-use-android-12",
        session_id: str = None,
    ):
        self.agent_bay_client = AgentBayClient()
        self.agent_bay = self.agent_bay_client.agent_bay
        self.agent_bay_session: AgentBaySession = self.create_session(
            image_id=image_id,
            session_id=session_id,
        )
        self.session_id = self.agent_bay_session.session_id
        bucket_name = os.environ.get("EDS_OSS_BUCKET_NAME")
        endpoint = os.environ.get("EDS_OSS_ENDPOINT")
        self.oss_client = OSSClient(bucket_name, endpoint)

    def create_session(self, image_id: str, session_id: str = None) -> Any:
        agent_bay_session = AgentBaySession(
            self.agent_bay,
            self.agent_bay_client,
            image_id,
            session_id,
        )
        # 初始化环境
        if not session_id:
            # 安装adb
            status, rsp = self.check_and_setup_app(
                "http://dashscope-cn-hangzhou."
                "oss-cn-hangzhou-internal.aliyuncs.com/"
                "wy_file/ADBKeyboard.apk",
                "ADBKeyboard.apk",
                agent_bay_session,
            )
            # time.sleep(60)
            print("首次创建，初始化结束")
        return agent_bay_session

    def search_session(self, session_id: str = None) -> Any:
        # 初始化环境
        if session_id:
            session = self.agent_bay_client.search_session(session_id)
            session.status = "RUNNING"
            return session
        else:
            session = self.agent_bay_client.search_session(self.session_id)
            session.status = "RUNNING"
            return session

    def close_session(
        self,
        image_id: str = "computer-use-windows-server-2022",
        session_id: str = None,
    ) -> Tuple[str, str]:

        if not session_id:
            agent_bay_session = AgentBaySession(
                self.agent_bay,
                self.agent_bay_client,
                image_id,
                session_id,
            )
            agent_bay_session.clean_session()
            return "success", f"clear session: {session_id}"
        else:
            self.agent_bay_session.clean_session()
            return "success", "clear all"

    def download_and_install_apk(
        self,
        oss_url: str,
        apk_name: str,
        agent_bay_session: Any,
    ) -> tuple[bool, str]:
        """
        从OSS地址下载APK文件并安装

        Args:
            oss_url (str): APK文件的OSS下载地址
            apk_name (str): APK文件名
            agent_bay_session: session 对象
        Returns:
            tuple: (status, response) 安装状态和响应信息
        """
        # 下载APK文件到云手机
        download_path = f"/data/local/tmp/{apk_name}"
        # download_command = f"curl -o {download_path} {oss_url}"
        # 合并下载和安装命令，使用分号分隔
        combined_command = (
            f"curl -o {download_path} {oss_url} && pm install {download_path}"
        )

        try:
            status, response = agent_bay_session.execute_command(
                combined_command,
            )

            if not status:
                return False, f"下载或安装失败: {response or '未知错误'}"

            # 判断安装是否成功（检查输出中是否包含Success）
            if response and "Success" in response:
                return True, response
            else:
                return False, f"安装失败: {response or '未知错误'}"

        except Exception as e:
            return False, f"下载并安装APK时出错: {str(e)}"

    def check_and_setup_app(
        self,
        internal_oss_url: str,
        app_name: str,
        agent_bay_session: Any,
    ) -> tuple[bool, str | None]:
        if internal_oss_url is None or app_name is None:
            return False, "param is empty"

        status_in, response_in = self.download_and_install_apk(
            internal_oss_url,
            app_name,
            agent_bay_session,
        )

        # 返回原来的输入法ID，以便后续恢复
        return status_in, response_in

    def run_command(self, command: str) -> tuple[str, str | None]:
        try:
            response = self.agent_bay_session.execute_command(command)
            return response.success, response.output
        except Exception as e:
            self.agent_bay_session.clean_session()
            logger.log(
                level=logging.ERROR,
                msg=f"get_screenshot_oss_url failed:{e}",
            )

        return "failed", ""

    def press_key(
        self,
        key: str = None,
        key_combination: list[str] = None,
    ) -> str:
        key_map = {
            "HOME": 3,
            "BACK": 4,
            "MENU": 82,
        }
        if key_combination:
            for k in key_combination:
                self.agent_bay_session.press_key(key_map[k])
            return "The key combination has been pressed."
        if key and key in key_map:
            self.agent_bay_session.press_key(key_map[key])
            return "The key combination has been pressed."
        return "key not supported"

    def long_press(
        self,
        x: int,
        y: int,
        press_time: str,
    ) -> tuple[str, str | None]:
        time_ms = int(press_time) * 1000
        return self.agent_bay_session.execute_command(
            f"input swipe {x} {y} {x} {y} {time_ms}",
        )

    def type(self, text: str) -> str | None:
        time_start = time.time()
        # 转义文本内容
        escaped_text = text.replace('"', '\\"').replace("'", "\\'")

        # 组合完整命令：检查输入法 -> 安装ADBKeyboard(如需要) ->
        # 启用并设置ADBKeyboard -> 发送文本 -> 禁用ADBKeyboard
        # 注意：这里简化处理，假设ADBKeyboard已经安装
        combined_command = (
            f"ime enable com.android.adbkeyboard/.AdbIME && "
            f"ime set com.android.adbkeyboard/.AdbIME && "
            f"sleep 0.3 && "
            f'am broadcast -a ADB_INPUT_TEXT --es msg "{escaped_text}" && '
            f"sleep 0.2 && "
            f"ime disable com.android.adbkeyboard/.AdbIME"
        )

        status, rsp = self.agent_bay_session.execute_command(
            combined_command,
            slot_time=0.5,
        )
        print(rsp)
        print(f"输入文字耗时：{time.time() - time_start}")
        return rsp

    def tab__(
        self,
        x1: int,
        y1: int,
        x2: int,
        y2: int,
        width: int,
        height: int,
    ) -> tuple[bool, str | None]:
        x, y = int((x1 + x2) / 2), int((y1 + y2) / 2)
        input_x = int(x / 1000 * width)
        input_y = int(y / 1000 * height)
        self.agent_bay_session.click(input_x, input_y)
        return True, f"The mouse has clicked at ({input_x}, {input_y})."

    def click_and_type(self, x: int, y: int, text: str) -> str:
        self.agent_bay_session.click(x, y)
        self.agent_bay_session.input_text(text)
        return f"The mouse has clicked and typed the text at ({x}, {y})."

    def append_text(self, x: int, y: int, text: str) -> str:
        self.agent_bay_session.click(x, y)
        self.agent_bay_session.input_text(text)
        self.agent_bay_session.press_key(26)
        return f"Append the content at ({x}, {y}) with {text} and press Enter"

    def kill_the_front_app(self, action: str) -> tuple[str, str | None]:
        command = (
            "am force-stop $(dumpsys activity activities | "
            "grep mResumedActivity"
            " | awk '{print $4}' | cut -d "
            "'/' -f 1)"
        )
        return self.agent_bay_session.execute_command(command)

    def home(self, action: str) -> str:
        self.agent_bay_session.press_key(3)
        return f"This {action} has been done"

    def slide(self, x1: int, y1: int, x2: int, y2: int) -> str:
        return self.agent_bay_session.swipe(x1, y1, x2, y2)

    def back(self, action: str) -> str:
        self.agent_bay_session.press_key(4)
        return f"This {action} has been done"

    def menu(self, action: str) -> str:
        self.agent_bay_session.press_key(82)
        return f"This {action} has been done"

    def enter(self, action: str) -> str:
        self.agent_bay_session.press_key(26)
        return "Enter key pressed."

    async def get_screenshot_base64_save_local_by_oss(
        self,
        local_save_path: str,
        max_retry: int = 5,
    ) -> str:
        session = self.agent_bay_session
        for _ in range(max_retry):
            screen_base64 = (
                await session.get_screenshot_base64_save_local_by_oss_(
                    local_save_path,
                )
            )
            if screen_base64:
                return screen_base64
        return "Error"

    def get_screenshot_oss_url(self) -> str:
        try:
            url = self.agent_bay_session.get_screenshot_oss_url()
            if url:
                return url
        except Exception as e:
            self.agent_bay_session.clean_session()
            logger.log(
                level=logging.ERROR,
                msg=f"get_screenshot_oss_url failed:{e}",
            )

        return "Error"


class AgentBayClient:

    def __init__(self) -> None:
        try:
            self.agent_bay = AgentBay(
                api_key=os.environ.get("AGENTBAY_API_KEY"),
            )

        except AgentBayError as e:
            print(f"Error: {e}")

    def search_session(self, session_id: str) -> Any:
        try:
            session = Session(agent_bay=self.agent_bay, session_id=session_id)
            session_info = session.info()
            session.resource_url = session_info.data.resource_url
            return session
        except Exception as e:
            print(f"Error: {e}")
            return None

    def delete_session_by_id(self, session_id: str) -> Any:
        try:
            session = self.search_session(session_id)
            if session:
                response = self.agent_bay.delete(session)
                return response
        except AgentBayError as e:
            print(f"Error: {e}")


class AgentBayComputerWy(SandboxBase):
    def __init__(
        self,
        image_id: str = "computer-use-windows-server-2022",
        session_id: str = None,
    ):
        # self.agent_bay_client = AgentBayClient()
        self.agent_bay_instance = AgentBayComputerWyInstance(
            image_id=image_id,
            session_id=session_id,
        )

    # 抽象方法重写
    def execute_wait_time_set(self, execute_wait_time: int = 5) -> str:
        global execute_wait_time_
        execute_wait_time_ = execute_wait_time
        print("set slot time to " + str(execute_wait_time_))
        return "The slot time has been set."

    def run_command(
        self,
        command: str,
        background: bool = False,
        timeout: int = 5,
        ope_type: str = None,
    ) -> str:
        try:
            status, response = self.agent_bay_instance.run_command_power_shell(
                command,
            )
            return f"command has benn done {status},res: {response}"
        except Exception as e:
            # self.agent_bay_instance.agent_bay_session.clean_session()
            logger.log(
                level=logging.ERROR,
                msg=f"get_screenshot_oss_url failed:{e}",
            )

        return "command has benn done failed"

    def press_key(
        self,
        key: str = None,
        key_combination: List[str] = None,
        ope_type: str = None,
    ) -> str:
        try:
            if key_combination:
                for k in key_combination:
                    status, res = self.agent_bay_instance.press_key(key)
                return "The key combination has been pressed"
        except Exception as e:
            logger.log(level=logging.ERROR, msg=f"press_key failed: {e}")
        return "Failed to press key combination"

    def long_press(self, x: int, y: int, press_time: str) -> str:
        return OperationStatus.DEVICE_UN_SUPPORTED_OPERATION.value

    def type_text(self, text: str, ope_type: str = None) -> str:
        return OperationStatus.DEVICE_UN_SUPPORTED.value

    def click_element(
        self,
        query: str,
        click_command: Callable,
        action_name: str = "click",
    ) -> str:
        return OperationStatus.DEVICE_UN_SUPPORTED.value

    def click(
        self,
        x: int = 0,
        y: int = 0,
        count: int = 1,
        query: str = "",
        action_name: str = "click",
        ope_type: str = None,
        x2: int = 0,
        y2: int = 0,
        width: int = 0,
        height: int = 0,
    ) -> str:
        self.agent_bay_instance.tap(x, y, count)
        return f"The mouse has clicked {count} times at ({x}, {y})."

    def right_click(
        self,
        x: int,
        y: int,
        count: int = 1,
        ope_type: str = None,
    ) -> str:
        self.agent_bay_instance.right_tap(x, y, count)
        return f"The mouse has right clicked at ({x}, {y})."

    def click_and_type(
        self,
        x: int,
        y: int,
        text: str,
        ope_type: str = None,
    ) -> str:
        self.agent_bay_instance.tap_type_enter(x, y, text)
        return f"The mouse has clicked and typed the text at ({x}, {y})."

    def append_text(
        self,
        x: int,
        y: int,
        text: str,
        ope_type: str = None,
    ) -> str:
        self.agent_bay_instance.append(x, y, text)
        return f"Append the content at ({x}, {y}) with {text} and press Enter"

    async def launch_app(self, app: str, ope_type: str = None) -> str:
        self.agent_bay_instance.open_app(app)
        return f"The application {app} has been launched."

    async def go_home(self, action: str) -> str:
        self.agent_bay_instance.home()
        return f"This {action} has been done"

    async def slide(self, x1: int, y1: int, x2: int, y2: int) -> str:
        return OperationStatus.DEVICE_UN_SUPPORTED.value

    async def back(self, action: str) -> str:
        return OperationStatus.DEVICE_UN_SUPPORTED.value

    async def menu(self, action: str) -> str:
        return OperationStatus.DEVICE_UN_SUPPORTED.value

    async def enter(self, action: str) -> str:
        return OperationStatus.DEVICE_UN_SUPPORTED.value

    async def kill_front_app(self, action: str) -> str:
        return OperationStatus.DEVICE_UN_SUPPORTED.value

    def upload_file_and_sign(self, filepath: str, file_name: str) -> str:
        return self.agent_bay_instance.in_upload_file_and_sign(
            filepath,
            file_name,
        )

    def get_screenshot_oss_url(self, max_retry: int = 1) -> str:
        try:
            for _ in range(max_retry):
                url = self.agent_bay_instance.get_screenshot_oss_url()
                if url:
                    return url
        except Exception as e:
            # self.agent_bay_session.clean_session()
            logger.log(
                level=logging.ERROR,
                msg=f"get_screenshot_oss_url failed:{e}",
            )

        return "Error"


class AgentBayComputerWyInstance:
    def __init__(
        self,
        image_id: str = "computer-use-windows-server-2022",
        session_id: str = None,
    ):
        self.agent_bay_client = AgentBayClient()
        self.agent_bay = self.agent_bay_client.agent_bay
        self.agent_bay_session = self.create_session(
            image_id=image_id,
            session_id=session_id,
        )
        self.ratio = 1
        self.ctrl_key = "ctrl"
        self.session_id = self.agent_bay_session.session_id
        bucket_name = os.environ.get("EDS_OSS_BUCKET_NAME")
        endpoint = os.environ.get("EDS_OSS_ENDPOINT")
        self.oss_client = OSSClient(bucket_name, endpoint)

    def create_session(self, image_id: str, session_id: str = None) -> Any:
        agent_bay_session = AgentBaySession(
            self.agent_bay,
            self.agent_bay_client,
            image_id,
            session_id,
        )
        # 初始化环境
        if not session_id:
            # 首次创建，需要初始化环境，安装python依赖
            print("首次创建，需要初始化环境，安装python依赖")
            status, res = self.init_session_python_pip(
                agent_bay_session=agent_bay_session,
            )
            time.sleep(60)
            status, res = self.install_python_packages(
                agent_bay_session=agent_bay_session,
            )
            time.sleep(30)
            print("首次创建，初始化结束")
        return agent_bay_session

    def close_session(
        self,
        image_id: str = "computer-use-windows-server-2022",
        session_id: str = None,
    ) -> Tuple[str, str]:

        if not session_id:
            agent_bay_session = AgentBaySession(
                self.agent_bay,
                self.agent_bay_client,
                image_id,
                session_id,
            )
            agent_bay_session.clean_session()
            return "success", f"clear session: {session_id}"
        else:
            self.agent_bay_session.clean_session()
            return "success", "clear all"

    def init_session_python_pip(
        self,
        agent_bay_session: Any,
        python_version: str = "3.10.11",
    ) -> Tuple[str, str]:
        """
        在远程 Windows 会话中安装 Python（如果未安装）
        """
        # 构建 PowerShell 安装脚本
        powershell_script = f"""
# 设置下载路径和版本
$version = "{python_version}"
$installerName = "python-$version-amd64.exe"
$downloadUrl = "https://mirrors.aliyun.com/python-release/windows/" + `
               "$installerName"
$pythonInstaller = "$env:TEMP\\$installerName"

$installDir = "C:\\Program Files\\Python310"
$scriptsDir = "$installDir\\Scripts"

# 检查是否已安装 python.exe
if (Get-Command python -ErrorAction SilentlyContinue) {{
    Write-Host "Python 已安装，跳过安装步骤。" -ForegroundColor Green
}} else {{
    Write-Host "Python 未检测到，开始安装 $version ..." -ForegroundColor Yellow

    # 下载安装包
    Write-Host "正在从阿里云下载 $installerName ..." -ForegroundColor Green
    try {{
        Invoke-WebRequest -Uri $downloadUrl `
                          -OutFile $pythonInstaller `
                          -TimeoutSec 300
    }} catch {{
        Write-Error "下载失败: $_"
        exit 1
    }}

    # 静默安装
    Write-Host "正在安装 Python $version ..." -ForegroundColor Green
    try {{
        Start-Process -Wait -FilePath $pythonInstaller `
                      -ArgumentList "/quiet", `
                                   "InstallAllUsers=1", `
                                   "PrependPath=0" `
                      -PassThru -ErrorAction Stop
    }} catch {{
        Write-Error "安装失败: $_"
        exit 1
    }}

    # 清理安装包
    Remove-Item -Force $pythonInstaller -ErrorAction SilentlyContinue

    # ========== 添加 Python 到系统 PATH ==========
    $currentPath = [Environment]::GetEnvironmentVariable("Path", `
                                                         "Machine") `
                   -split ";" | Where-Object {{$_}}
    $pathsToAdd = @($installDir, $scriptsDir)
    $updated = $false

    foreach ($path in $pathsToAdd) {{
        $cleanPath = $path.TrimEnd('\\')
        if (-not ($currentPath | Where-Object {{ $_.TrimEnd('\\') -eq `
                                                 $cleanPath }}) `
                -and (Test-Path $path)) {{
            $currentPath += $path
            $updated = $true
            Write-Host "已添加到系统 PATH: $path" -ForegroundColor Cyan
        }}
    }}

    if ($updated) {{
        $newPath = $currentPath -join ";"
        [Environment]::SetEnvironmentVariable("Path", `
                                              $newPath, `
                                              "Machine")
        Write-Host "系统 PATH 已更新。" -ForegroundColor Green
    }}
}}

Write-Host "Python 安装完成。" -ForegroundColor Green
"""

        # 将整个 PowerShell 脚本进行 Base64 编码
        encoded_command = base64.b64encode(
            powershell_script.encode("utf-16le"),
        ).decode("ascii")

        # 构造执行命令
        command = f"powershell -EncodedCommand {encoded_command}"

        # 执行安装命令
        return agent_bay_session.execute_command(
            command=command,
            timeout=6000000,
        )

    def install_python_packages(
        self,
        agent_bay_session: Any,
    ) -> Tuple[str, str]:
        """
        在远程 Windows 会话中使用 pip 安装指定的 Python 包。
        使用阿里云镜像加速下载，并确保 pip 自身为最新版本。
        """
        powershell_script = """
# 确保当前会话能使用 python
$env:Path = [Environment]::GetEnvironmentVariable("Path", "Machine") + `
            ";" + [Environment]::GetEnvironmentVariable("Path", "User")

# 检查 Python 是否可用
if (!(Get-Command python -ErrorAction SilentlyContinue)) {
    Write-Error "Python 未安装或未加入 PATH，请先安装 Python。"
    exit 1
}

# 升级 pip 到最新版本
Write-Host "正在升级 pip ..." -ForegroundColor Green
python -m pip install --upgrade pip -i https://mirrors.aliyun `
      --.com/pypi/simple/trusted-host mirrors.aliyun.com

# 定义要安装的包列表（支持自定义索引）
$packages = @(
    "pyautogui",
    "requests",
    "pyperclip",
    "pynput"
)

$extra_index = "https://mirrors.aliyun.com/pypi/simple/"
$trusted_host = "mirrors.aliyun.com"

foreach ($pkg in $packages) {
    Write-Host "正在安装 $pkg ..." -ForegroundColor Green
    $result = python -m pip install $pkg -i $extra_index `
          --trusted-host $trusted_host

    if ($LASTEXITCODE -ne 0) {
        Write-Error "安装 $pkg 失败。"
        exit $LASTEXITCODE
    } else {
        Write-Host "$pkg 安装成功。" -ForegroundColor Cyan
    }
}

Write-Host "所有包安装完成！" -ForegroundColor Green
"""

        encoded_script = base64.b64encode(
            powershell_script.encode("utf-16le"),
        ).decode("ascii")

        # 构造执行命令
        command = f"powershell -EncodedCommand {encoded_script}"

        # 执行命令（假设 execute_command 返回 (stdout, stderr)）
        return agent_bay_session.execute_command(
            command=command,
            timeout=6000000,
        )

    def set_screen_resolution_ps(
        self,
        agent_bay_session: Any,
        width: int,
        height: int,
    ) -> Tuple[str, str]:
        """
        使用PowerShell设置Windows屏幕分辨率（最简版本）

        Args:
            width (int): 屏幕宽度
            height (int): 屏幕高度

        Returns:
            Tuple[str, str]: (状态, 响应信息)
        """
        # 使用简单的 PowerShell 命令
        powershell_cmd = f"""
$w = {width}; $h = {height};
Set-ItemProperty -Path 'HKCU:\\Control Panel\\Desktop\\
WindowMetrics' -Name 'AppliedDPI' -Value 96 -Type DWord;
Set-ItemProperty -Path 'HKCU:\\Control Panel\\
Desktop' -Name 'DeskTop' -Value "${{w}},${{h}}";
'分辨率设置命令已执行'
"""

        # 使用Base64编码避免特殊字符问题
        import base64

        encoded_cmd = base64.b64encode(
            powershell_cmd.encode("utf-16le"),
        ).decode("ascii")

        command = f"powershell -EncodedCommand {encoded_cmd}"

        return agent_bay_session.execute_command(
            command=command,
            timeout=15000,
        )

    def get_screenshot_oss_url(self, max_retry: int = 1) -> str:
        try:
            for _ in range(max_retry):
                url = self.agent_bay_session.get_screenshot_oss_url()
                if url:
                    return url
        except Exception as e:
            self.agent_bay_session.clean_session()
            logger.log(
                level=logging.ERROR,
                msg=f"get_screenshot_oss_url failed:{e}",
            )

        return "Error"

    def in_upload_file_and_sign(self, filepath: str, file_name: str) -> str:
        return self.oss_client.oss_upload_file_and_sign(filepath, file_name)

    def run_command_power_shell(
        self,
        command: str,
        slot_time: float = None,
        timeout: int = 30,
    ) -> Tuple[str, str]:

        try:
            return self.agent_bay_session.execute_command(
                command=command,
                slot_time=slot_time,
                timeout=timeout,
            )
        except Exception as e:
            self.agent_bay_session.clean_session()
            logger.log(
                level=logging.ERROR,
                msg=f"run_command_power_shell failed:{e}",
            )

        return "failed", ""

    def open_app(self, name: str) -> Tuple[str, str]:
        # 构建Python脚本
        script_content = f"""# -*- coding: utf-8 -*-
import pyautogui
import pyperclip
import time
import re
pyautogui.FAILSAFE = False
ctrl_key = '{self.ctrl_key}'
def contains_chinese(text):
    return bool(re.search(r'[\\u4e00-\\u9fff]', text))
name = '{name}'
if 'Outlook' in name:
    name = name.replace('Outlook', 'Outlook new')
print('Action: open {name}')
# 打开 Windows 搜索栏
pyautogui.press('win')
time.sleep(0.5)
pyautogui.typewrite(name)
# 如果包含中文，则使用粘贴方式（备用方案）
if contains_chinese(name):
    pyperclip.copy(name)
    pyautogui.hotkey(ctrl_key, 'v')
# 回车确认
time.sleep(1)
pyautogui.press('enter')"""

        # 使用base64编码脚本内容
        import base64

        script_b64 = base64.b64encode(script_content.encode("utf-8")).decode(
            "ascii",
        )

        # 在远程机器上创建脚本文件并执行
        temp_script = "temp_launch_script.py"

        # 使用PowerShell命令创建文件并执行，指定UTF-8编码
        command = (
            f'powershell "'
            f"$env:Path += ';C:\\Program Files\\Python310;'; "
            f"$s=[System.Convert]::FromBase64String('{script_b64}'); "
            f"$d=[System.Text.Encoding]::UTF8.GetString($s); "
            f"Set-Content -Path {temp_script} -Value $d -Encoding UTF8; "
            f"python {temp_script}"
            f'"'
        )

        return self.agent_bay_session.execute_command(command)

    def home(self) -> Tuple[str, str]:
        # 构建Python脚本
        script_content = """# -*- coding: utf-8 -*-
import pyautogui
pyautogui.FAILSAFE = False
key1 = 'win'
key2 = 'd'
pyautogui.keyDown(key1)
pyautogui.keyDown(key2)
pyautogui.keyUp(key2)
pyautogui.keyUp(key1)"""

        # 使用base64编码脚本内容
        import base64

        script_b64 = base64.b64encode(script_content.encode("utf-8")).decode(
            "ascii",
        )

        # 在远程机器上创建脚本文件并执行
        temp_script = "temp_launch_script.py"

        # 使用PowerShell命令创建文件并执行，指定UTF-8编码
        command = (
            f'powershell "'
            f"$env:Path += ';C:\\Program Files\\Python310;'; "
            f"$s=[System.Convert]::FromBase64String('{script_b64}'); "
            f"$d=[System.Text.Encoding]::UTF8.GetString($s); "
            f"Set-Content -Path {temp_script} -Value $d -Encoding UTF8; "
            f"python {temp_script}"
            f'"'
        )

        return self.agent_bay_session.execute_command(command)

    def back(self, action: str) -> str:
        self.agent_bay_session.press_key(4)
        return f"This {action} has been done"

    def menu(self, action: str) -> str:
        self.agent_bay_session.press_key(82)
        return f"This {action} has been done"

    def enter(self, action: str) -> str:
        self.agent_bay_session.press_key(26)
        return "Enter key pressed."

    def tap(self, x: int, y: int, count: int = 1) -> Tuple[str, str]:
        script_content = f"""# -*- coding: utf-8 -*-
import pyautogui
from pynput.mouse import Button, Controller
pyautogui.FAILSAFE = False
ratio = {self.ratio}
x = {x}
y = {y}
count = {count}
x, y = x//ratio, y//ratio
print('Action: click (%d, %d) %d times' % (x, y, count))
mouse = Controller()
pyautogui.moveTo(x,y)
mouse.click(Button.left, count=count)"""
        # 使用base64编码脚本内容
        import base64

        script_b64 = base64.b64encode(script_content.encode("utf-8")).decode(
            "ascii",
        )

        # 在远程机器上创建脚本文件并执行
        temp_script = "temp_launch_script.py"

        # 使用PowerShell命令创建文件并执行，指定UTF-8编码
        command = (
            f'powershell "'
            f"$env:Path += ';C:\\Program Files\\Python310;'; "
            f"$s=[System.Convert]::FromBase64String('{script_b64}'); "
            f"$d=[System.Text.Encoding]::UTF8.GetString($s); "
            f"Set-Content -Path {temp_script} -Value $d -Encoding UTF8; "
            f"python {temp_script}"
            f'"'
        )
        return self.agent_bay_session.execute_command(command)

    def right_tap(self, x: int, y: int, count: int = 1) -> Tuple[str, str]:
        script_content = f"""# -*- coding: utf-8 -*-
import pyautogui
from pynput.mouse import Button, Controller
pyautogui.FAILSAFE = False
ratio = {self.ratio}
x = {x}
y = {y}
count = {count}
x, y = x//ratio, y//ratio
print('Action: right click (%d, %d) %d times' % (x, y, count))
pyautogui.rightClick(x, y)"""
        # 使用base64编码脚本内容
        import base64

        script_b64 = base64.b64encode(script_content.encode("utf-8")).decode(
            "ascii",
        )

        # 在远程机器上创建脚本文件并执行
        temp_script = "temp_launch_script.py"

        # 使用PowerShell命令创建文件并执行，指定UTF-8编码
        command = (
            f'powershell "'
            f"$env:Path += ';C:\\Program Files\\Python310;'; "
            f"$s=[System.Convert]::FromBase64String('{script_b64}'); "
            f"$d=[System.Text.Encoding]::UTF8.GetString($s); "
            f"Set-Content -Path {temp_script} -Value $d -Encoding UTF8; "
            f"python {temp_script}"
            f'"'
        )
        return self.agent_bay_session.execute_command(command)

    def hotkey(self, key_list: List[str]) -> Tuple[str, str]:
        script_content = f"""# -*- coding: utf-8 -*-
import pyautogui
pyautogui.FAILSAFE = False
pyautogui.hotkey('{key_list[0]}', '{key_list[1]}')"""
        # 使用base64编码脚本内容
        import base64

        script_b64 = base64.b64encode(script_content.encode("utf-8")).decode(
            "ascii",
        )

        # 在远程机器上创建脚本文件并执行
        temp_script = "temp_launch_script.py"

        # 使用PowerShell命令创建文件并执行，指定UTF-8编码
        command = (
            f'powershell "'
            f"$env:Path += ';C:\\Program Files\\Python310;'; "
            f"$s=[System.Convert]::FromBase64String('{script_b64}'); "
            f"$d=[System.Text.Encoding]::UTF8.GetString($s); "
            f"Set-Content -Path {temp_script} -Value $d -Encoding UTF8; "
            f"python {temp_script}"
            f'"'
        )
        return self.agent_bay_session.execute_command(command)

    def press_key(self, key: str) -> Tuple[str, str]:
        script_content = f"""# -*- coding: utf-8 -*-
import pyautogui
pyautogui.FAILSAFE = False
pyautogui.press('{key}')"""
        # 使用base64编码脚本内容
        import base64

        script_b64 = base64.b64encode(script_content.encode("utf-8")).decode(
            "ascii",
        )

        # 在远程机器上创建脚本文件并执行
        temp_script = "temp_launch_script.py"

        # 使用PowerShell命令创建文件并执行，指定UTF-8编码
        command = (
            f'powershell "'
            f"$env:Path += ';C:\\Program Files\\Python310;'; "
            f"$s=[System.Convert]::FromBase64String('{script_b64}'); "
            f"$d=[System.Text.Encoding]::UTF8.GetString($s); "
            f"Set-Content -Path {temp_script} -Value $d -Encoding UTF8; "
            f"python {temp_script}"
            f'"'
        )
        return self.agent_bay_session.execute_command(command)

    def tap_type_enter(self, x: int, y: int, text: str) -> Tuple[str, str]:
        script_content = f"""# -*- coding: utf-8 -*-
import pyautogui
import pyperclip
import time
pyautogui.FAILSAFE = False
ratio = {self.ratio}
ctrl_key = '{self.ctrl_key}'
x = {x}
y = {y}
text = '{text}'
x, y = x//ratio, y//ratio
print('Action: click (%d, %d), enter %s and press Enter' % (x, y, text))
pyautogui.click(x=x, y=y)
time.sleep(0.5)
pyperclip.copy(text)
pyautogui.keyDown(ctrl_key)
pyautogui.keyDown('v')
pyautogui.keyUp('v')
pyautogui.keyUp(ctrl_key)
time.sleep(0.5)
pyautogui.press('enter')"""
        # 使用base64编码脚本内容
        import base64

        script_b64 = base64.b64encode(script_content.encode("utf-8")).decode(
            "ascii",
        )

        # 在远程机器上创建脚本文件并执行
        temp_script = "temp_launch_script.py"

        # 使用PowerShell命令创建文件并执行，指定UTF-8编码
        command = (
            f'powershell "'
            f"$env:Path += ';C:\\Program Files\\Python310;'; "
            f"$s=[System.Convert]::FromBase64String('{script_b64}'); "
            f"$d=[System.Text.Encoding]::UTF8.GetString($s); "
            f"Set-Content -Path {temp_script} -Value $d -Encoding UTF8; "
            f"python {temp_script}"
            f'"'
        )
        return self.agent_bay_session.execute_command(command)

    def drag(self, x1: int, y1: int, x2: int, y2: int) -> Tuple[str, str]:
        script_content = f"""# -*- coding: utf-8 -*-
import pyautogui
pyautogui.FAILSAFE = False
ratio = {self.ratio}
x1 = {x1}
y1 = {y1}
x2 = {x2}
y2 = {y2}
x1, y1 = x1//ratio, y1//ratio
x2, y2 = x2//ratio, y2//ratio
pyautogui.moveTo(x1,y1)
pyautogui.mouseDown()
pyautogui.moveTo(x2,y2,duration=0.5)
pyautogui.mouseUp()
print('Action: drag from (%d, %d) to (%d, %d)' % (x1, y1, x2, y2))"""
        # 使用base64编码脚本内容
        import base64

        script_b64 = base64.b64encode(script_content.encode("utf-8")).decode(
            "ascii",
        )

        # 在远程机器上创建脚本文件并执行
        temp_script = "temp_launch_script.py"

        # 使用PowerShell命令创建文件并执行，指定UTF-8编码
        command = (
            f'powershell "'
            f"$env:Path += ';C:\\Program Files\\Python310;'; "
            f"$s=[System.Convert]::FromBase64String('{script_b64}'); "
            f"$d=[System.Text.Encoding]::UTF8.GetString($s); "
            f"Set-Content -Path {temp_script} -Value $d -Encoding UTF8; "
            f"python {temp_script}"
            f'"'
        )
        return self.agent_bay_session.execute_command(command)

    def mouse_move(self, x: int, y: int) -> Tuple[str, str]:
        script_content = f"""# -*- coding: utf-8 -*-
import pyautogui
pyautogui.FAILSAFE = False
ratio = {self.ratio}
x = {x}
y = {y}
x, y = x//ratio, y//ratio
pyautogui.moveTo(x,y)"""
        # 使用base64编码脚本内容
        import base64

        script_b64 = base64.b64encode(script_content.encode("utf-8")).decode(
            "ascii",
        )

        # 在远程机器上创建脚本文件并执行
        temp_script = "temp_launch_script.py"

        # 使用PowerShell命令创建文件并执行，指定UTF-8编码
        command = (
            f'powershell "'
            f"$env:Path += ';C:\\Program Files\\Python310;'; "
            f"$s=[System.Convert]::FromBase64String('{script_b64}'); "
            f"$d=[System.Text.Encoding]::UTF8.GetString($s); "
            f"Set-Content -Path {temp_script} -Value $d -Encoding UTF8; "
            f"python {temp_script}"
            f'"'
        )
        return self.agent_bay_session.execute_command(command)

    def middle_click(self, x: int, y: int) -> str:
        script = f"""
import pyautogui
pyautogui.FAILSAFE = False
ratio = {self.ratio}
x = {x}
y = {y}
pyautogui.middleClick(x, y)
""".strip().replace(
            "\n",
            ";",
        )
        powershell_prefix = "powershell"
        path_command = '$env:Path += \\";C:\\Program Files\\Python310;\\"'
        python_command = f'python -c \\"{script}\\"'
        command = f"{powershell_prefix} {path_command} ; {python_command}"
        status, response = self.agent_bay_session.execute_command(command)
        return f"The scroll has been {status} {response}"

    def type_with_clear_enter(
        self,
        text: str,
        clear: int,
        enter: int,
    ) -> str:
        # 构建Python脚本
        script_content = f"""# -*- coding: utf-8 -*-
        import pyautogui
import pyperclip
import time
ratio = {self.ratio}
ctrl_key = '{self.ctrl_key}'
text = '{text}'
clear = {clear}
enter = {enter}
if clear == 1:
    pyautogui.keyDown(ctrl_key)
    pyautogui.keyDown('a')
    pyautogui.keyUp('a')
    pyautogui.keyUp(ctrl_key)
    pyautogui.press('backspace')
    time.sleep(0.5)
pyperclip.copy(text)
pyautogui.keyDown(ctrl_key)
pyautogui.keyDown('v')
pyautogui.keyUp('v')
pyautogui.keyUp(ctrl_key)
time.sleep(0.5)
if enter == 1:
    pyautogui.press('enter')"""

        # 使用base64编码脚本内容
        import base64

        script_b64 = base64.b64encode(script_content.encode("utf-8")).decode(
            "ascii",
        )

        # 在远程机器上创建脚本文件并执行
        temp_script = "temp_launch_script.py"

        # 使用PowerShell命令创建文件并执行，指定UTF-8编码
        command = (
            f'powershell "'
            f"$env:Path += ';C:\\Program Files\\Python310;'; "
            f"$s=[System.Convert]::FromBase64String('{script_b64}'); "
            f"$d=[System.Text.Encoding]::UTF8.GetString($s); "
            f"Set-Content -Path {temp_script} -Value $d -Encoding UTF8; "
            f"python {temp_script}"
            f'"'
        )
        status, response = self.agent_bay_session.execute_command(command)
        return f"The scroll has been {status} {response}"

    def type_with_clear_enter_pos(
        self,
        text: str,
        x: int,
        y: int,
        clear: int,
        enter: int,
    ) -> str:
        script_content = f"""# -*- coding: utf-8 -*-
import pyautogui
import pyperclip
import time
ratio = {self.ratio}
ctrl_key = '{self.ctrl_key}'
text = '{text}'
x = {x}
y = {y}
clear = {clear}
enter = {enter}
x, y = x/ratio, y/ratio
pyautogui.click(x=x, y=y)
time.sleep(0.5)
if clear == 1:
    pyautogui.keyDown(ctrl_key)
    pyautogui.keyDown('a')
    pyautogui.keyUp('a')
    pyautogui.keyUp(ctrl_key)
    pyautogui.press('backspace')
    time.sleep(0.5)
pyperclip.copy(text)
pyautogui.keyDown(ctrl_key)
pyautogui.keyDown('v')
pyautogui.keyUp('v')
pyautogui.keyUp(ctrl_key)
time.sleep(0.5)
if enter == 1:
    pyautogui.press('enter')"""

        # 使用base64编码脚本内容
        import base64

        script_b64 = base64.b64encode(script_content.encode("utf-8")).decode(
            "ascii",
        )

        # 在远程机器上创建脚本文件并执行
        temp_script = "temp_launch_script.py"

        # 使用PowerShell命令创建文件并执行，指定UTF-8编码
        command = (
            f'powershell "'
            f"$env:Path += ';C:\\Program Files\\Python310;'; "
            f"$s=[System.Convert]::FromBase64String('{script_b64}'); "
            f"$d=[System.Text.Encoding]::UTF8.GetString($s); "
            f"Set-Content -Path {temp_script} -Value $d -Encoding UTF8; "
            f"python {temp_script}"
            f'"'
        )
        status, response = self.agent_bay_session.execute_command(command)
        return f"The scroll has been {status} {response}"

    def scroll_pos(self, x: int, y: int, pixels: int) -> str:
        script_content = f"""# -*- coding: utf-8 -*-
import pyautogui
import time
ratio = {self.ratio}
x = {x}
y = {y}
pixels = {pixels}*150
x, y = x//ratio, y//ratio
pyautogui.moveTo(x, y)
time.sleep(0.5)
pyautogui.scroll(pixels)
print('scroll_pos')"""

        # 使用base64编码脚本内容
        import base64

        script_b64 = base64.b64encode(script_content.encode("utf-8")).decode(
            "ascii",
        )

        # 在远程机器上创建脚本文件并执行
        temp_script = "temp_launch_script.py"

        # 使用PowerShell命令创建文件并执行，指定UTF-8编码
        command = (
            f'powershell "'
            f"$env:Path += ';C:\\Program Files\\Python310;'; "
            f"$s=[System.Convert]::FromBase64String('{script_b64}'); "
            f"$d=[System.Text.Encoding]::UTF8.GetString($s); "
            f"Set-Content -Path {temp_script} -Value $d -Encoding UTF8; "
            f"python {temp_script}"
            f'"'
        )
        status, response = self.agent_bay_session.execute_command(command)
        return f"The scroll has been {status} {response}"

    def scroll(self, pixels: int) -> str:
        script_content = f"""# -*- coding: utf-8 -*-
import pyautogui
pixels = {pixels}*150
pyautogui.scroll(pixels)
print('scroll')"""
        # 使用base64编码脚本内容
        import base64

        script_b64 = base64.b64encode(script_content.encode("utf-8")).decode(
            "ascii",
        )

        # 在远程机器上创建脚本文件并执行
        temp_script = "temp_launch_script.py"

        # 使用PowerShell命令创建文件并执行，指定UTF-8编码
        command = (
            f'powershell "'
            f"$env:Path += ';C:\\Program Files\\Python310;'; "
            f"$s=[System.Convert]::FromBase64String('{script_b64}'); "
            f"$d=[System.Text.Encoding]::UTF8.GetString($s); "
            f"Set-Content -Path {temp_script} -Value $d -Encoding UTF8; "
            f"python {temp_script}"
            f'"'
        )
        status, response = self.agent_bay_session.execute_command(command)
        return f"The scroll has been {status} {response}"


class AgentBaySession:

    def __init__(
        self,
        agent_bay: AgentBay,
        agent_bay_client: AgentBayClient,
        image_id: str = "mobile-use-android-12",
        session_id: str = None,
    ) -> None:
        try:
            # Create a session with labels
            if not session_id:
                params = CreateSessionParams()
                params.labels = {
                    "purpose": "demo",
                    "environment": "development",
                }
                params.image_id = "code_latest"
                if image_id:
                    params.image_id = image_id
                # params.image_id = "computer-use-windows-server-2022"
                session_result = agent_bay.create(params)
                self.session_data = session_result.session
            else:
                self.session_data = agent_bay_client.search_session(session_id)
            self.session_id = self.session_data.session_id

        except AgentBayError as e:
            self.clean_session()
            print(f"Error: {e}")

    def execute_command(
        self,
        command: str,
        slot_time: float = None,
        timeout: int = 600000,
    ) -> Tuple[str, str]:
        # 执行命令
        try:
            # Execute a command
            response = self.session_data.command.execute_command(
                command,
                timeout_ms=timeout,
            )
            if slot_time:
                time.sleep(slot_time)
            if response.success:
                return response.success, response.output
        except Exception as e:
            self.clean_session()
            logger.log(level=logging.ERROR, msg=f"execute command failed:{e}")
        return "False", ""

    def get_screenshot_base64_save_local_by_oss_(
        self,
        local_save_path: str,
    ) -> str:
        try:
            screenshot_result = self.session_data.ui.screenshot()
            data = json.loads(screenshot_result.data)
            img_url = data.get("ResourceUrl", "")
            if not img_url:
                return ""
            return download_oss_image_and_save_return_base64(
                img_url,
                local_save_path,
            )
        except Exception as e:
            # self.clean_session()
            logger.log(level=logging.ERROR, msg=f"run code failed:{e}")
        return ""

    def get_screenshot_oss_url(self) -> str:
        try:
            screenshot_result = self.session_data.ui.screenshot()
            return screenshot_result.data
        except Exception as e:
            self.clean_session()
            logger.log(level=logging.ERROR, msg=f"run code failed:{e}")
        return ""

    def clean_session(self) -> Any:
        try:
            # Clean up
            delete_result = self.session_data.delete()
            return delete_result
        except Exception as e:
            logger.log(level=logging.ERROR, msg=f"run code failed:{e}")

    def press_key(self, key: int) -> Any:
        try:
            response = self.session_data.ui.send_key(key)
            return response
        except Exception as e:
            logger.log(level=logging.ERROR, msg=f"press key failed:{e}")
        return None

    def input_text(self, text: str) -> Any:
        try:
            # 目前phone不支持中文，computer支持
            response = self.session_data.ui.input_text(text)
            return response
        except Exception as e:
            logger.log(level=logging.ERROR, msg=f"input text failed:{e}")

    def click(self, x: int, y: int, button: str = "left") -> Any:
        try:
            response = self.session_data.ui.click(x, y, button)
            return response
        except Exception as e:
            logger.log(level=logging.ERROR, msg=f"tap failed:{e}")

    def swipe(self, x1: int, y1: int, x2: int, y2: int) -> Any:
        try:
            response = self.session_data.ui.swipe(x1, y1, x2, y2)
            return response
        except Exception as e:
            logger.log(level=logging.ERROR, msg=f"swip failed:{e}")


class SessionInfo(BaseModel):
    # 云手机设备信息查询字段返回类
    android_instance_name: str
    android_instance_id: str
    network_interface_ip: str
    instance_status: str


if __name__ == "__main__":
    agent = AgentBayPhoneWy(session_id="")
    info = agent.agent_bay_instance.search_session(session_id="")
    # agent = AgentBayComputerWy(session_id="")
    # agent_session = agent.agent_bay_instance.agent_bay_session
    # response = agent.launch_app("Google Chrome")
    # response = agent.go_home("home")
    session = agent.agent_bay_instance.agent_bay_session
    result_clean = session.clean_session()
