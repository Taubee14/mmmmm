# -*- coding: utf-8 -*-
import asyncio
import json
import os
from concurrent.futures import ThreadPoolExecutor
from typing import Any, Optional, List

import pytest
import time
import traceback

from agentbricks.models import BaseLLM
from agentbricks.schemas.oai_llm import (
    Parameters,
    UserMessage,
    Role,
)
from agentbricks.tracing import create_handler, get_tracer
from agentbricks.tracing.base import BaseLogHandler, Tracer, TraceType
from agentbricks.tracing.dashscope_log import DashscopeLogHandler
from agentbricks.tracing.tracing_util import TracingUtil
from agentbricks.tracing.wrapper import trace


def test_create_handler_default():
    """Test create_handler with default mode."""
    handlers = create_handler(eval_mode="default")
    assert len(handlers) == 1
    assert isinstance(handlers[0], BaseLogHandler)


@pytest.fixture
def log_dir(tmp_path):
    """Fixture to provide a temporary directory for logs."""
    return tmp_path / "logs"


def test_create_handler_dashscope_log(log_dir):
    """Test create_handler with dashscope_log mode."""
    handlers = create_handler(
        eval_mode="dashscope_log",
        log_level=20,
        log_dir=str(log_dir),
    )
    assert len(handlers) == 1
    handler = handlers[0]
    assert isinstance(handler, DashscopeLogHandler)

    # Check if log directory is created
    assert log_dir.exists(), f"Log directory '{log_dir}' does not exist"

    # Trigger on_start and verify log file content
    handler.on_start(
        event_type=TraceType.LLM,
        payload={"user_id": "test_user"},
    )
    info_log_file = log_dir / f"info.log.{os.getpid()}"
    assert (
        info_log_file.exists()
    ), f"Info log file '{info_log_file}' does not exist"

    with open(info_log_file, "r") as f:
        log_lines = f.readlines()
        assert len(log_lines) > 0, "No log entries found in info log file"
        log_entry = json.loads(log_lines[-1])
        assert log_entry["step"] == "llm_start", "Unexpected step in log entry"
        assert (
            log_entry["user_id"] == "test_user"
        ), "Unexpected user_id in log entry"

    # Trigger on_error and verify error log file content
    try:
        raise ValueError("Test error")
    except Exception as e:
        handler.on_error(
            event_type=TraceType.LLM,
            start_payload={"user_id": "test_user"},
            error=e,
            start_time=time.time(),
            traceback_info=traceback.format_exc(),
        )

    error_log_file = log_dir / f"error.log.{os.getpid()}"
    assert (
        error_log_file.exists()
    ), f"Error log file '{error_log_file}' does not exist"

    with open(error_log_file, "r") as f:
        log_lines = f.readlines()
        assert len(log_lines) > 0, "No log entries found in error log file"
        log_entry = json.loads(log_lines[-1])
        assert log_entry["step"] == "llm_error", "Unexpected step in log entry"
        assert (
            log_entry["code"] == "ValueError"
        ), "Unexpected error code in log entry"


def test_get_tracer():
    """Test get_tracer returns the same instance for the same eval_mode."""
    tracer1 = get_tracer(eval_mode="default")
    tracer2 = get_tracer(eval_mode="default")
    assert tracer1 is tracer2


def test_base_log_handler(caplog):
    """Test BaseLogHandler logs messages correctly."""
    caplog.set_level("INFO")
    handler = BaseLogHandler()
    handler.on_start(event_type=TraceType.LLM, payload={"key": "value"})
    handler.on_end(
        event_type=TraceType.LLM,
        start_payload={"key": "value"},
        end_payload={},
        start_time=0,
    )
    assert "Event llm started" in caplog.text
    assert "Event llm ended" in caplog.text


def test_tracer_event_context():
    """Test Tracer event context management."""
    tracer = Tracer(handlers=[BaseLogHandler()])
    with tracer.event(event_type=TraceType.LLM, payload={"key": "value"}):
        tracer.log(
            "Test message",
        )  # Use Tracer's log method instead of EventContext
    assert True  # Ensure no exceptions were raised


def test_tracer_custom_log():
    """Test Tracer custom log method."""
    tracer = Tracer(handlers=[DashscopeLogHandler(enable_console=True)])
    with tracer.event(
        event_type=TraceType.LLM,
        payload={"key": "value"},
    ) as event:
        tracer.log("msg1", **{"key1": "value1", "key2": {"key3": "value3"}})
        event.on_log(
            "msg2",
            **{"step_suffix": "last_resp", "payload": {"key": "value"}},
        )
    assert True


def test_aliyun_tracer():
    """Test Tracer custom log method."""
    tracer = Tracer(
        handlers=[
            DashscopeLogHandler(enable_console=True),
        ],
    )

    trace_header = {"baggage": "", "traceparent": "", "tracestate": ""}

    with tracer.event(
        event_type="TEST_TRACE",
        event_name="test_aliyun_trace",
        payload={"input_key": "input_value"},
    ) as event:
        event.set_trace_header(trace_header)
        tracer.log("msg1", **{"key1": "value1", "key2": {"key3": "value3"}})
        event.on_log(
            "msg2",
            **{"step_suffix": "last_resp", "payload": {"key": "value"}},
        )
    assert True


def test_llm_trace():
    @trace(trace_type=TraceType.LLM, trace_name="test_llm")
    async def test_llm(**kwargs: Any):
        trace_event = kwargs.pop("trace_event", None)
        if trace_event:
            trace_event.set_attribute(
                "func_llm.key",
                json.dumps({"key0": "value0", "key1": "value1"}),
            )

        chunks = []
        llm = BaseLLM()
        user_text_message = UserMessage(
            content="床前明月光，后三句是什么？",
            role=Role.USER,
        )
        parameters = Parameters(stream_options={"include_usage": True})
        async for chunk in llm.astream(
            model="qwen-max",
            messages=[user_text_message],
            parameters=parameters,
        ):
            chunks.append(chunk)
            print("astream chunk:", chunk)

    TracingUtil.set_request_id("test_req_llm")
    common_attributes = {
        "gen_ai.user.id": "user_id_llm",
        "bailian.app.id": "app_id_llm",
        "bailian.app.owner_id": "app_id_llm",
        "bailian.app.env": "pre_llm",
        "bailian.app.workspace": "workspace_llm",
    }
    TracingUtil.set_common_attributes(common_attributes)

    asyncio.run(test_llm())


def test_func():
    @trace(trace_type="TEST_TRACE", trace_name="test_func_1")
    def test_func_1():
        pass

    @trace(trace_type="TEST_TRACE", trace_name="test_func_2")
    def test_func_2(**kwargs: Any):

        trace_event = kwargs.pop("trace_event", None)
        if trace_event:
            trace_event.set_attribute("func_2.key", "func_2.value")

        test_func_1()
        print(f"func_2_info: kwargs={kwargs}")

    @trace(trace_type="TEST_TRACE", trace_name="test_func_3")
    def test_func_3(a: str):

        test_func_2()

        print(f"func_3_info: a={a}")

    @trace(trace_type="TEST_TRACE", trace_name="test_func_4")
    def test_func_4(a: int, **kwargs: Any):
        print(f"func_4_info: a={a}, kwargs={kwargs}")

        test_func_3("3")

        trace_event = kwargs.pop("trace_event", None)
        if trace_event:
            trace_event.set_attribute("func_4.key", "func_4.value")

        return a + 1

    @trace(trace_type="TEST_TRACE", trace_name="test_func_5")
    def test_func_5(a: str, **kwargs: Any):
        print(f"func_5_info: a={a}, kwargs={kwargs}")

        trace_event = kwargs.pop("trace_event", None)
        if trace_event:
            trace_event.set_attribute("func_5.key", "func_5.value")

        test_func_4(2, **kwargs)

        return a + "_subfix"

    @trace(trace_type="TEST_TRACE", trace_name="test_func_6")
    def test_func_6(a: str, **kwargs: Any):
        print(f"func_6_info: a={a}, kwargs={kwargs}")
        output = {"in": a, "res": "b"}

        test_func_5(a, **kwargs)

        trace_event = kwargs.pop("trace_event", None)
        if trace_event:
            trace_event.set_attribute("func_6.key", "func_6.value")

        return output

    @trace(trace_type="TEST_TRACE", trace_name="test_func_7")
    def test_func_7(a: dict, **kwargs: Any):
        print(f"func_7_info: a={a}, kwargs={kwargs}")
        output = {"in": a, "res": "b"}

        trace_event = kwargs.pop("trace_event", None)
        if trace_event:
            trace_event.set_attribute(
                "func_7.key",
                json.dumps({"key0": "value0", "key1": "value1"}),
            )

        test_func_6(a.get("input"), **kwargs)

        return output

    test_func_1()
    common_attributes_1 = {
        "gen_ai.user.id": "user_id_1",
        "bailian.app.id": "app_id_1",
        "bailian.app.owner_id": "owner_id_1",
        "bailian.app.env": "pre_1",
        "bailian.app.workspace": "workspace_1",
    }
    TracingUtil.set_request_id("req_1")
    TracingUtil.set_common_attributes(common_attributes_1)
    test_func_2(**{"test_2_1_key": "test_2_1_value"})  # test_func_2 span 1
    #
    # common_attributes_2 = {
    #     "gen_ai.user.id": "user_id_2",
    #     "bailian.app.id": "app_id_2",
    #     "bailian.app.owner_id": "app_id_2",
    #     "bailian.app.env": "pre",
    # }
    # TracingUtils.set_request_id("req_2")
    # TracingUtils.set_common_attributes(common_attributes_2)
    # test_func_2(**{"test_2_2_key": "test_2_2_value"}) # test_func_2 span 2
    #
    # common_attributes_3 = {
    #     "gen_ai.user.id": "user_id_3",
    #     "bailian.app.id": "app_id_3",
    #     "bailian.app.owner_id": "app_id_3",
    # }
    # TracingUtils.set_request_id("req_3")
    # TracingUtils.set_common_attributes(common_attributes_3)
    # test_func_2(**{"test_2_3_key": "test_2_3_value"}) # test_func_2 span 3
    #
    common_attributes_4 = {
        "gen_ai.user.id": "user_id_4",
        "bailian.app.id": "app_id_4",
    }
    TracingUtil.set_request_id("req_4")
    TracingUtil.set_common_attributes(common_attributes_4)
    test_func_7({"input": "test_7"}, **{"test_7_key": "test_7_value"})


@trace(trace_type="TEST_TRACE", trace_name="atest_func1")
async def atest_func1(a: str, **kwargs: Any):
    print(f"func_1_info: a={a}, kwargs={kwargs}")
    await asyncio.sleep(0.1)
    return "func_1_result_" + a


@trace(trace_type="TEST_TRACE", trace_name="atest_func2")
async def atest_func2(a: str, **kwargs: Any):
    print(f"func_2_info: a={a}, kwargs={kwargs}")
    await asyncio.sleep(0.2)
    return "func_2_result_" + a


@trace(trace_type="TEST_TRACE", trace_name="atest_func3")
async def atest_func3(a: str, **kwargs: Any):
    print(f"func_3_info: a={a}, kwargs={kwargs}")
    await asyncio.sleep(0.3)
    return "func_3_result_" + a


@trace(trace_type="TEST_TRACE", trace_name="atest_func4")
async def atest_func4(a: str, **kwargs: Any):
    print(f"func_4_info: a={a}, kwargs={kwargs}")
    await asyncio.sleep(0.4)
    return "func_4_result_" + a


@trace(trace_type="TEST_TRACE", trace_name="atest_func")
async def atest_func(a: str, **kwargs: Any):
    tasks = [
        atest_func1(a, **kwargs),
        atest_func2(a, **kwargs),
        atest_func3(a, **kwargs),
        atest_func4(a, **kwargs),
    ]

    results = ""
    for task in asyncio.as_completed(tasks):
        results += await task

    # task_results = await asyncio.gather(*tasks)
    # for task_result in task_results:
    #     results += task_result

    return results


@trace(
    trace_type="TEST_TRACE",
    trace_name="atest_top_func",
    get_finish_reason_func=None,
    merge_output_func=None,
)
async def atest_top_func():
    result = await atest_func("test_a")
    yield result
    return


def get_finish_reason(resp: str):
    if "stop" in resp:
        return "stop"


def merge_output(resp: List[str]):
    return "__".join(resp)


@trace(
    trace_type="TEST_TRACE",
    trace_name="astream_test_func_1",
    get_finish_reason_func=get_finish_reason,
    merge_output_func=merge_output,
)
async def astream_test_func_1(a: str):
    for i in range(0, 5):
        print("astream_test_func_1")
        await asyncio.sleep(0.1)
        yield a + "_func1_" + str(i)
    yield "stop"


@trace(
    trace_type="TEST_TRACE",
    trace_name="astream_test_func_2",
    get_finish_reason_func=get_finish_reason,
    merge_output_func=merge_output,
)
async def astream_test_func_2(a: str):
    for i in range(0, 5):
        print("astream_test_func_2")
        await asyncio.sleep(0.1)
        yield a + "_func2_" + str(i)

    yield "stop"


async def collect_async_generator(agen):
    """辅助函数：消费一个异步生成器，返回所有字符串拼接结果"""
    parts = []
    async for item in agen:
        parts.append(item)
    return "__".join(parts)


@trace(
    trace_type="TEST_TRACE",
    trace_name="astream_test_func",
)
async def astream_test_func(a: str):
    print("astream_test_func")

    gen1 = astream_test_func_1(a)
    gen2 = astream_test_func_2(a)

    result1, result2 = await asyncio.gather(
        collect_async_generator(gen1),
        collect_async_generator(gen2),
    )

    print(f'astream_test_func end: {result1 + "_____" + result2}')

    return result1 + "_____" + result2


@trace(
    trace_type="TEST_TRACE",
    trace_name="stream_test_func_1",
    get_finish_reason_func=get_finish_reason,
    merge_output_func=merge_output,
)
def stream_test_func_1(a: str, **kwargs):
    for i in range(0, 5):
        print("astream_test_func_1")
        time.sleep(0.1)
        yield a + "_func1_" + str(i)
    yield "stop"


@trace(
    trace_type="TEST_TRACE",
    trace_name="stream_test_func_2",
    get_finish_reason_func=get_finish_reason,
    merge_output_func=merge_output,
)
def stream_test_func_2(a: str, **kwargs):
    for i in range(0, 5):
        print("astream_test_func_2")
        time.sleep(0.1)
        yield a + "_func2_" + str(i)

    yield "stop"


def collect_sync_generator(gen):
    """辅助函数：消费一个异步生成器，返回所有字符串拼接结果"""
    parts = []
    for item in gen:
        parts.append(item)
    return "__".join(parts)


@trace(
    trace_type="TEST_TRACE",
    trace_name="astream_test_func",
)
def stream_test_func(a: str, **kwargs):
    print("stream_test_func")

    trace_event = kwargs.pop("trace_event", None)
    trace_args = {}
    if trace_event:
        trace_context = trace_event.get_trace_context()
        trace_args["trace_context"] = trace_context

    print(f"trace_args: {trace_args}")

    gen1 = stream_test_func_1(a, **trace_args)
    gen2 = stream_test_func_2(a, **trace_args)

    with ThreadPoolExecutor(max_workers=2) as executor:
        future1 = executor.submit(collect_sync_generator, gen1)
        future2 = executor.submit(collect_sync_generator, gen2)
        result1 = future1.result()
        result2 = future2.result()
        print(f'stream_test_func end: {result1 + "_____" + result2}')
        return result1 + "_____" + result2


async def main():
    async for item in atest_top_func():
        print(item)


if __name__ == "__main__":
    TracingUtil.set_request_id("test_req_id")

    # test_aliyun_tracer()
    # test_llm_trace()
    # test_func()
    # asyncio.run(atest_func("a"))
    # asyncio.run(main())
    # asyncio.run(astream_test_func("a"))
    stream_test_func("a")
