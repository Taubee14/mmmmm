# -*- coding: utf-8 -*-
"""
Tree searches functionality
"""

import json
import asyncio
import numpy as np
import logging
from typing import Any
from jsonschema import validate
from .schemas import (
    SEARCH_DECISION_SCHEMA,
    DIRECTORY_SELECTION_SCHEMA,
    MULTI_TOOL_SEARCH_SCHEMA,
)
from .prompts import (
    SEARCH_DECISION_PROMPT,
    SEARCH_DECISION_SYSTEM_PROMPT,
    DIRECTORY_SELECTION_PROMPT,
    DIRECTORY_SELECTION_SYSTEM_PROMPT,
    MULTI_TOOL_SEARCH_PROMPT,
    MULTI_TOOL_SEARCH_SYSTEM_PROMPT,
)


class SearchManager:
    """Search manager"""

    def __init__(self, tree_instance: Any) -> None:
        self.tree = tree_instance
        self.logger = logging.getLogger(__name__)

    async def search(
        self,
        query: str,
        max_depth: int = 3,
    ) -> dict:
        """Search for tools related to the query in the tree

        Uses logarithmic time complexity searches algorithm,
        guided by LLM to quickly locate relevant tools

        Args:
            query: User's tool requirements or problem description
            max_depth: Maximum depth of subtree displayed each time
            max_results: Maximum number of results returned

        Returns:
            List of found relevant tools
        """

        current_node = self.tree.root
        history = []  # ä¿å­˜æœç´¢è·¯å¾„
        found_tools = {}

        self.logger.info(f"å¼€å§‹æœç´¢: {query}")
        self.logger.info("-" * 50)

        while current_node and (current_node.is_directory or not found_tools):
            history.append(current_node.name)

            # è·å–å½“å‰èŠ‚ç‚¹çš„å¯è§†åŒ–å­æ ‘
            subtree = current_node.visualize_tree(
                debug=False,
                bfs_depth=max_depth,
                description=True,
            )

            # åˆ†æå½“å‰èŠ‚ç‚¹æ˜¯å¦åŒ…å«å·¥å…·å­èŠ‚ç‚¹
            has_tools = any(
                not child.is_directory for child in current_node.children
            )
            has_dirs = any(
                child.is_directory for child in current_node.children
            )

            if has_tools:
                # æ„å»ºæœç´¢æç¤ºï¼ŒæŒ‡å¯¼LLMé€‰æ‹©æœ€ç›¸å…³çš„å·¥å…·æˆ–è¿›ä¸€æ­¥çš„ç›®å½•
                json_schema = SEARCH_DECISION_SCHEMA
                path = " > ".join(history)

                prompt = SEARCH_DECISION_PROMPT.format(
                    query=query,
                    path=path,
                    subtree=subtree,
                )

                messages = [
                    {
                        "role": "system",
                        "content": SEARCH_DECISION_SYSTEM_PROMPT.format(
                            json_schema=json_schema,
                        ),
                    },
                    {"role": "user", "content": prompt},
                ]

                try:
                    response = self.tree.ask_llm(
                        messages=messages,
                        response_format={
                            "type": "json_schema",
                            "json_schema": {
                                "name": "search_decision",
                                "schema": json_schema,
                            },
                            "strict": True,
                        },
                    )

                    decision = json.loads(response)
                    next_action = decision.get("next")
                    selected_node = decision.get("selected_node")
                    reason = decision.get("reason", "")

                    self.logger.info(f"å†³ç­–: {next_action} -> {selected_node}")
                    self.logger.info(f"åŸå› : {reason}")
                    self.logger.info("-" * 30)

                    if next_action == "select_tool":
                        # é€‰æ‹©äº†å…·ä½“å·¥å…·
                        tool_node = self.tree.get_node_by_name(selected_node)
                        if tool_node and not tool_node.is_directory:
                            found_tools[tool_node.name] = {
                                "description": tool_node.description,
                                "path": history + [tool_node.name],
                                "relevance": "é«˜",  # ç›´æ¥é€‰æ‹©çš„å·¥å…·ç›¸å…³æ€§é«˜
                                "reason": reason,
                            }
                            break

                    elif next_action == "explore_directory":
                        # é€‰æ‹©è¿›å…¥å­ç›®å½•ç»§ç»­æœç´¢
                        next_node = self.tree.get_node_by_name(selected_node)
                        if next_node and next_node.is_directory:
                            current_node = next_node
                            continue
                        else:
                            self.logger.warning(
                                f"æ‰¾ä¸åˆ°ç›®å½• '{selected_node}' æˆ–å®ƒä¸æ˜¯ä¸€ä¸ªç›®å½•",
                            )

                    elif next_action == "back":
                        # è¿”å›ä¸Šçº§
                        if len(history) > 1:  # ç¡®ä¿ä¸ä¼šè¿”å›åˆ°æ ¹èŠ‚ç‚¹ä¹‹ä¸Š
                            history.pop()  # ç§»é™¤å½“å‰èŠ‚ç‚¹
                            parent_name = history[-1]  # è·å–çˆ¶èŠ‚ç‚¹åç§°
                            current_node = self.tree.get_node_by_name(
                                parent_name,
                            )
                            continue

                    elif next_action == "end":
                        # ç»“æŸæœç´¢
                        break

                except Exception as e:
                    self.logger.error(f"è§£ææœç´¢å†³ç­–æ—¶å‡ºé”™: {e}")
                    break

            elif has_dirs and not found_tools:
                # å¦‚æœå½“å‰èŠ‚ç‚¹åªæœ‰ç›®å½•å­èŠ‚ç‚¹ï¼Œæ²¡æœ‰å·¥å…·ï¼Œè‡ªåŠ¨é€‰æ‹©æœ€ç›¸å…³çš„ç›®å½•
                json_schema = DIRECTORY_SELECTION_SCHEMA
                path = " > ".join(history)

                prompt = DIRECTORY_SELECTION_PROMPT.format(
                    query=query,
                    path=path,
                    subtree=subtree,
                )

                messages = [
                    {
                        "role": "system",
                        "content": DIRECTORY_SELECTION_SYSTEM_PROMPT.format(
                            json_schema=json_schema,
                        ),
                    },
                    {"role": "user", "content": prompt},
                ]

                try:
                    response = self.tree.ask_llm(
                        messages=messages,
                        response_format={
                            "type": "json_schema",
                            "json_schema": {
                                "name": "directory_selection",
                                "schema": json_schema,
                            },
                            "strict": True,
                        },
                    )
                    decision = json.loads(response)
                    selected_directory = decision.get("selected_directory")
                    reason = decision.get("reason", "")

                    self.logger.info(f"é€‰æ‹©ç›®å½•: {selected_directory}")
                    self.logger.info(f"åŸå› : {reason}")
                    self.logger.info("-" * 30)

                    next_node = self.tree.get_node_by_name(selected_directory)
                    if next_node and next_node.is_directory:
                        current_node = next_node
                    else:
                        self.logger.warning(
                            f"æ‰¾ä¸åˆ°ç›®å½• '{selected_directory}' æˆ–å®ƒä¸æ˜¯ä¸€ä¸ªç›®å½•",
                        )
                        break

                except Exception as e:
                    self.logger.error(f"è§£æç›®å½•é€‰æ‹©æ—¶å‡ºé”™: {e}")
                    break
            else:
                # æ—¢æ²¡æœ‰å·¥å…·ä¹Ÿæ²¡æœ‰å­ç›®å½•ï¼Œæˆ–è€…æ˜¯å¶å­èŠ‚ç‚¹ï¼Œç»“æŸæœç´¢
                break

        # æœç´¢ç»“æŸï¼Œæ•´ç†ç»“æœ
        self._print_search_results(found_tools)
        return found_tools

    async def multi_tool_search(
        self,
        query: str,
        max_depth: int = 3,
        max_results: int = 10,
        debug: bool = False,
    ) -> list:
        """Search for multiple tools related to the query in the tree

        Uses concurrent searches algorithm, for current node,
        if multiple child nodes match or are suspected, searches concurrently

        Args:
            query: User's tool requirements or problem description
            max_depth: Maximum depth of subtree displayed each time
            max_results: Maximum number of results returned

        Returns:
            List of found relevant tools, sorted by relevance
        """
        self.logger.info(f"å¼€å§‹å¤šå·¥å…·å¹¶å‘æœç´¢: {query}")
        self.logger.info("-" * 50)

        # ä»æ ¹èŠ‚ç‚¹å¼€å§‹å¹¶å‘æœç´¢
        found_tools = await self._concurrent_search_from_node(
            self.tree.root,
            query,
            max_depth,
            max_results,
            path=[],
        )

        # æŒ‰ç›¸å…³æ€§æ’åºç»“æœå¹¶è½¬æ¢ä¸ºåˆ—è¡¨
        sorted_tools = sorted(
            found_tools.items(),
            key=lambda x: x[1].get("relevance_score", 0),
            reverse=True,
        )

        # é™åˆ¶ç»“æœæ•°é‡å¹¶è½¬æ¢ä¸ºåˆ—è¡¨æ ¼å¼
        results = []
        for tool_name, tool_info in sorted_tools[:max_results]:
            results.append(
                {
                    "name": tool_name,
                    **tool_info,
                },
            )

        if debug:
            self._print_multi_tool_search_results_list(results)
        return results

    async def _concurrent_search_from_node(
        self,
        current_node: Any,
        query: str,
        max_depth: int,
        max_results: int,
        path: list,
    ) -> dict:
        """Concurrent searches starting from specified node

        Args:
            current_node: Current searches node
            query: Search query
            max_depth: Maximum depth
            max_results: Maximum results
            path: Current path

        Returns:
            Dictionary of found tools
        """
        found_tools = {}
        current_path = path + [current_node.name]

        self.logger.info(f"åœ¨èŠ‚ç‚¹ '{current_node.name}' è¿›è¡Œå¹¶å‘æœç´¢")

        # è·å–å½“å‰èŠ‚ç‚¹çš„å¯è§†åŒ–å­æ ‘
        subtree = current_node.visualize_tree(
            debug=False,
            bfs_depth=max_depth,
            description=True,
        )

        # ä½¿ç”¨LLMé€‰æ‹©ç›¸å…³çš„å·¥å…·å’Œç›®å½•
        json_schema = MULTI_TOOL_SEARCH_SCHEMA
        path_str = " > ".join(current_path)

        prompt = MULTI_TOOL_SEARCH_PROMPT.format(
            query=query,
            path=path_str,
            subtree=subtree,
        )

        messages = [
            {
                "role": "system",
                "content": MULTI_TOOL_SEARCH_SYSTEM_PROMPT.format(
                    json_schema=json_schema,
                ),
            },
            {"role": "user", "content": prompt},
        ]

        try:
            response = self.tree.ask_llm(
                messages=messages,
                response_format={
                    "type": "json_schema",
                    "json_schema": {
                        "name": "multi_tool_search",
                        "schema": json_schema,
                    },
                    "strict": True,
                },
            )

            decision = json.loads(response)
            next_action = decision.get("next")
            selected_nodes = decision.get("selected_nodes", [])
            reason = decision.get("reason", "")

            self.logger.info(f"å†³ç­–: {next_action}")
            self.logger.info(f"é€‰ä¸­èŠ‚ç‚¹: {selected_nodes}")
            self.logger.info(f"åŸå› : {reason}")
            self.logger.info("-" * 30)

            if next_action == "select_nodes":
                # å¤„ç†é€‰ä¸­çš„èŠ‚ç‚¹ï¼šå·¥å…·ç›´æ¥æ·»åŠ åˆ°ç»“æœï¼Œç›®å½•åˆ™ç»§ç»­æœç´¢
                selected_tools = []
                selected_dirs = []

                for node_name in selected_nodes:
                    node = self.tree.get_node_by_name(node_name)
                    if node:
                        if not node.is_directory:
                            # æ˜¯å·¥å…·ï¼Œç›´æ¥æ·»åŠ åˆ°ç»“æœä¸­
                            found_tools[node.name] = {
                                "description": node.description,
                                "path": current_path + [node.name],
                                "relevance_score": 80,  # é»˜è®¤é«˜ç›¸å…³æ€§
                                "reason": reason,
                                "source": "tree_search",
                            }
                            selected_tools.append(node.name)
                            self.logger.info(f"âœ… é€‰ä¸­å·¥å…·: {node.name}")
                        else:
                            # æ˜¯ç›®å½•ï¼ŒåŠ å…¥å¾…æœç´¢åˆ—è¡¨
                            selected_dirs.append(node.name)
                            self.logger.info(f"ğŸ“ é€‰ä¸­ç›®å½•: {node.name}")

                # å¦‚æœæœ‰é€‰ä¸­çš„ç›®å½•ä¸”è¿˜éœ€è¦æ›´å¤šç»“æœï¼Œå¹¶å‘æœç´¢è¿™äº›ç›®å½•
                if selected_dirs and len(found_tools) < max_results:
                    self.logger.info(
                        f"å¹¶å‘æœç´¢ {len(selected_dirs)} ä¸ªé€‰ä¸­ç›®å½•...",
                    )
                    concurrent_results = (
                        await self._search_multiple_directories_concurrently(
                            selected_dirs,
                            query,
                            max_depth,
                            max_results - len(found_tools),
                            current_path,
                        )
                    )
                    found_tools.update(concurrent_results)

            elif next_action == "back":
                # è¿”å›ä¸Šçº§
                self.logger.info("é€‰æ‹©è¿”å›ä¸Šçº§")

            elif next_action == "end":
                # ç»“æŸæœç´¢
                self.logger.info("é€‰æ‹©ç»“æŸæœç´¢")

        except Exception as e:
            self.logger.error(f"è§£æå¤šå·¥å…·æœç´¢å†³ç­–æ—¶å‡ºé”™: {e}")

        return found_tools

    async def _search_multiple_directories_concurrently(
        self,
        dir_names: list,
        query: str,
        max_depth: int,
        max_results: int,
        current_path: list,
    ) -> dict:
        """Search multiple directories concurrently

        Args:
            dir_names: List of directory names
            query: Search query
            max_depth: Maximum depth
            max_results: Maximum results
            current_path: Current path

        Returns:
            Merged searches results
        """
        # asyncio already imported at line 7

        self.logger.info(f"å¼€å§‹å¹¶å‘æœç´¢ {len(dir_names)} ä¸ªç›®å½•: {dir_names}")

        # åˆ›å»ºå¹¶å‘æœç´¢ä»»åŠ¡
        tasks = []
        for dir_name in dir_names:
            dir_node = self.tree.get_node_by_name(dir_name)
            if dir_node and dir_node.is_directory:
                task = self._concurrent_search_from_node(
                    dir_node,
                    query,
                    max_depth,
                    max_results // len(dir_names) + 1,
                    current_path,
                )
                tasks.append(task)

        # ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆ
        if tasks:
            results_list = await asyncio.gather(*tasks, return_exceptions=True)

            # åˆå¹¶ç»“æœ
            combined_results = {}
            for i, result in enumerate(results_list):
                if isinstance(result, dict):
                    # ä¸ºæ¯ä¸ªç»“æœæ·»åŠ æ¥æºä¿¡æ¯
                    for tool_name, tool_info in result.items():
                        if tool_name not in combined_results:
                            tool_info["concurrent_source"] = (
                                dir_names[i]
                                if i < len(dir_names)
                                else "unknown"
                            )
                            combined_results[tool_name] = tool_info
                        else:
                            # å¦‚æœå·¥å…·å·²å­˜åœ¨ï¼Œé€‰æ‹©ç›¸å…³æ€§æ›´é«˜çš„
                            if tool_info.get(
                                "relevance_score",
                                0,
                            ) > combined_results[tool_name].get(
                                "relevance_score",
                                0,
                            ):
                                combined_results[tool_name] = tool_info
                elif isinstance(result, Exception):
                    self.logger.error(f"å¹¶å‘æœç´¢ä»»åŠ¡å‡ºé”™: {result}")

            self.logger.info(
                f"å¹¶å‘æœç´¢å®Œæˆï¼Œåˆå¹¶å¾—åˆ° {len(combined_results)} ä¸ªå·¥å…·",
            )
            return combined_results

        return {}

    def _print_multi_tool_search_results_list(self, found_tools: list) -> None:
        """Print multi-tool searches results (list format)"""
        self.logger.info("\nå¤šå·¥å…·æœç´¢å®Œæˆ!")
        if found_tools:
            self.logger.info(f"æ‰¾åˆ° {len(found_tools)} ä¸ªç›¸å…³å·¥å…·:")
            for i, tool in enumerate(found_tools, 1):
                relevance_score = tool.get("relevance_score", 0)
                self.logger.info(
                    f"{i}. {tool['name']} (ç›¸å…³æ€§: {relevance_score}/100)",
                )
                self.logger.info(
                    f"   æè¿°: {tool.get('description', '')[:100]}...",
                )
                if "path" in tool:
                    self.logger.info(f"   è·¯å¾„: {' > '.join(tool['path'])}")
                if "reason" in tool:
                    self.logger.info(f"   ç†ç”±: {tool['reason']}")
                self.logger.info("")
        else:
            self.logger.info("æœªæ‰¾åˆ°ç›¸å…³å·¥å…·")

    def _print_search_results(self, found_tools: dict) -> None:
        """Print searches results"""
        self.logger.info("\næœç´¢å®Œæˆ!")
        if found_tools:
            self.logger.info(f"æ‰¾åˆ° {len(found_tools)} ä¸ªç›¸å…³å·¥å…·:")
            for i, tool_name in enumerate(found_tools, 1):
                tool = found_tools[tool_name]
                self.logger.info(
                    f"{i}. {tool_name} - {tool['description'][:100]}...",
                )
                self.logger.info(f"   è·¯å¾„: {' > '.join(tool['path'])}")
                self.logger.info(f"   ç›¸å…³æ€§: {tool['relevance']}")
                self.logger.info(f"   ç†ç”±: {tool['reason']}")
                self.logger.info("")
        else:
            self.logger.info("æœªæ‰¾åˆ°ç›¸å…³å·¥å…·")

    async def tool_similarity_search(
        self,
        query: str,
        top_k: int = 5,
        debug: bool = False,
    ) -> list:
        """Vector similarity-based direct tool searches

        Complementary method to tree searches,
        using embedding similarity directly

        Args:
            query: Query text
            top_k: Number of results returned

        Returns:
            List of top_k tools with highest similarity
        """
        # è·å–æŸ¥è¯¢çš„embedding
        query_embedding = np.array(self.tree.get_embedding(query))

        if query_embedding is None:
            self.logger.error("æ— æ³•è·å–æŸ¥è¯¢embedding")
            return []

        # æ”¶é›†æ‰€æœ‰å¶å­èŠ‚ç‚¹(å·¥å…·)
        tools = []

        def collect_tools(node: Any) -> None:
            if not node.is_directory:
                tools.append(node)
            for child in node.children:
                collect_tools(child)

        collect_tools(self.tree.root)

        # è®¡ç®—ç›¸ä¼¼åº¦
        tool_emb = self.tree.tree_emb[: len(tools)]

        # æŒ‰ç›¸ä¼¼åº¦æ’åº
        tool_scores = query_embedding @ tool_emb.T

        top_indices = np.argsort(tool_scores)[-1 : -top_k - 1 : -1]
        top_score = tool_scores[top_indices]

        # è¿”å›top_kä¸ªç»“æœçš„åˆ—è¡¨
        results = []
        for i, s in zip(top_indices, top_score):
            tool_name = self.tree.tree_node[i]
            tool_node = self.tree.get_node_by_name(tool_name)
            if tool_node:
                results.append(
                    {
                        "name": tool_name,
                        "description": tool_node.description,
                        "similarity": float(s),
                    },
                )

        if debug:
            self.logger.info("\nåŸºäºå‘é‡ç›¸ä¼¼åº¦æœç´¢ç»“æœ:")
            for i, result in enumerate(results, 1):
                self.logger.info(
                    f"{i}. {result['name']} (ç›¸ä¼¼åº¦: {result['similarity']:.4f})",
                )

        return results

    async def hybrid_search(self, query: str, max_results: int = 5) -> list:
        """Hybrid searches method combining tree searches and similarity
        searches

        First use tree searches for precise location,
        then use similarity searches to supplement results

        Args:
            query: User query
            max_results: Maximum number of results returned

        Returns:
            Hybrid searches results list
        """
        # æ ‘æœç´¢
        tree_results = await self.multi_tool_search(
            query,
            max_results=max_results,
        )

        # å¦‚æœæ ‘æœç´¢ç»“æœä¸è¶³ï¼Œè¡¥å……ç›¸ä¼¼åº¦æœç´¢
        if len(tree_results) < max_results:
            similarity_results = await self.tool_similarity_search(
                query,
                top_k=max_results - len(tree_results),
            )

            # åˆå¹¶ç»“æœï¼Œé¿å…é‡å¤
            existing_names = {result["name"] for result in tree_results}
            for sim_result in similarity_results:
                if (
                    sim_result["name"] not in existing_names
                    and len(tree_results) < max_results
                ):
                    tree_results.append(sim_result)

        return tree_results[:max_results]

    async def hybrid_multi_tool_search(
        self,
        query: str,
        max_results: int = 10,
        debug: bool = False,
    ) -> list:
        """Hybrid multi-tool searches method combining
        tree searches and similarity searches

        This is the most optimized searches method that can:
        1. Use multi-tool tree searches to find relevant tool combinations
        2. Use similarity searches to supplement missed relevant tools
        3. Deduplicate and sort results by relevance

        Args:
            query: User query
            max_results: Maximum number of results returned

        Returns:
            Optimized hybrid searches results list, sorted by relevance
        """
        self.logger.info(f"å¼€å§‹æ··åˆå¤šå·¥å…·æœç´¢: {query}")
        self.logger.info("=" * 60)

        # ç¬¬ä¸€é˜¶æ®µï¼šå¤šå·¥å…·æ ‘æœç´¢
        self.logger.info("é˜¶æ®µ1: æ‰§è¡Œå¤šå·¥å…·æ ‘æœç´¢...")
        tree_results = await self.multi_tool_search(
            query,
            max_results=max_results,
        )

        # è½¬æ¢æ ‘æœç´¢ç»“æœä¸ºdictæ ¼å¼ä¾¿äºå¤„ç†
        tree_results_dict = {result["name"]: result for result in tree_results}

        # ç¬¬äºŒé˜¶æ®µï¼šå¦‚æœç»“æœä¸è¶³ï¼Œä½¿ç”¨ç›¸ä¼¼åº¦æœç´¢è¡¥å……
        if len(tree_results_dict) - 5 < max_results:  # äº’è¡¥
            self.logger.info(
                f"é˜¶æ®µ2: æ ‘æœç´¢æ‰¾åˆ°{len(tree_results_dict)}ä¸ªå·¥å…·ï¼Œä½¿ç”¨ç›¸ä¼¼åº¦æœç´¢è¡¥å……...",
            )
            remaining_slots = max_results - len(tree_results_dict) + 2
            similarity_results = await self.tool_similarity_search(
                query,
                top_k=remaining_slots * 2,
            )  # è·å–æ›´å¤šå€™é€‰

            # åˆå¹¶ç»“æœï¼Œé¿å…é‡å¤
            for sim_result in similarity_results:
                tool_name = sim_result["name"]
                if (
                    tool_name not in tree_results_dict
                    and len(tree_results_dict) < max_results
                ):
                    # å°†ç›¸ä¼¼åº¦è½¬æ¢ä¸ºç›¸å…³æ€§è¯„åˆ† (0-100)
                    similarity_score = sim_result.get("similarity", 0)
                    relevance_score = min(int(similarity_score * 100), 100)

                    tree_results_dict[tool_name] = {
                        "name": tool_name,
                        "description": sim_result["description"],
                        "path": ["similarity_search", tool_name],
                        "relevance_score": relevance_score,
                    }

        # ç¬¬ä¸‰é˜¶æ®µï¼šç»“æœæ’åºå’Œä¼˜åŒ–
        self.logger.info("é˜¶æ®µ3: ä¼˜åŒ–å’Œæ’åºæœç´¢ç»“æœ...")

        # æŒ‰ç›¸å…³æ€§è¯„åˆ†æ’åºå¹¶è½¬æ¢ä¸ºåˆ—è¡¨
        sorted_results = sorted(
            tree_results_dict.values(),
            key=lambda x: x.get("relevance_score", 0),
            reverse=True,
        )

        # é™åˆ¶ç»“æœæ•°é‡
        final_results = sorted_results[:max_results]

        if debug:
            self._print_hybrid_search_results_list(final_results)
        return final_results

    def _print_hybrid_search_results_list(self, found_tools: list) -> None:
        """Print hybrid searches results (list format)"""
        self.logger.info("\næ··åˆå¤šå·¥å…·æœç´¢å®Œæˆ!")
        self.logger.info("=" * 60)

        if found_tools:
            self.logger.info(
                f"æ‰¾åˆ° {len(found_tools)} ä¸ªç›¸å…³å·¥å…· (æŒ‰ç›¸å…³æ€§æ’åº):",
            )
            self.logger.info("")

            tree_search_count = sum(
                1
                for tool in found_tools
                if tool.get("source") != "similarity_search"
            )
            similarity_search_count = len(found_tools) - tree_search_count

            self.logger.info("ğŸ“Š æœç´¢ç»Ÿè®¡:")
            self.logger.info(f"   - æ ‘æœç´¢å‘ç°: {tree_search_count} ä¸ªå·¥å…·")
            self.logger.info(
                f"   - ç›¸ä¼¼åº¦è¡¥å……: {similarity_search_count} ä¸ªå·¥å…·",
            )
            self.logger.info("")

            for i, tool in enumerate(found_tools, 1):
                relevance_score = tool.get("relevance_score", 0)
                source = tool.get("source", "tree_search")
                source_icon = "ğŸ¯" if source != "similarity_search" else "ğŸ”"

                self.logger.info(f"{source_icon} {i}. {tool['name']}")
                self.logger.info(f"   ç›¸å…³æ€§: {relevance_score}/100")
                self.logger.info(
                    f"   æè¿°: {tool.get('description', '')[:120]}...",
                )
                if "path" in tool:
                    self.logger.info(f"   è·¯å¾„: {' > '.join(tool['path'])}")
                if "reason" in tool:
                    self.logger.info(f"   ç†ç”±: {tool['reason']}")
                self.logger.info("")
        else:
            self.logger.info("âŒ æœªæ‰¾åˆ°ç›¸å…³å·¥å…·")
            self.logger.info("å»ºè®®ï¼š")
            self.logger.info("- å°è¯•ä½¿ç”¨æ›´å…·ä½“çš„å…³é”®è¯")
            self.logger.info("- æ£€æŸ¥å·¥å…·æ ‘æ˜¯å¦åŒ…å«ç›¸å…³å·¥å…·")
            self.logger.info("- è€ƒè™‘ä½¿ç”¨ä¸åŒçš„æœç´¢ç­–ç•¥")
