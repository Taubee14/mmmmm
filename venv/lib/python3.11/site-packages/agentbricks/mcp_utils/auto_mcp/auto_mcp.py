# -*- coding: utf-8 -*-
import json
import logging
import uuid
from typing import Any, Dict, List, Optional

from pydantic import BaseModel, Field

from agentbricks.base.component import Component
from agentbricks.tracing import TraceType
from agentbricks.tracing.wrapper import trace

logger = logging.getLogger(__name__)


class IndexConfig(BaseModel):
    """Index configuration class"""

    tree_file_path: str = Field(..., description="Tool tree file path")
    batch_size: int = Field(default=10, description="Batch processing size")
    max_items_per_node: int = Field(
        default=5,
        description="Maximum number of items per node",
    )
    stats: Dict[str, Any] = Field(
        default_factory=dict,
        description="Index statistics",
    )


class AutoMCPIndexInput(BaseModel):
    """Auto MCP Index input"""

    input_path: str = Field(..., description="Input file path")
    output_path: str = Field(
        default="tool_tree.json",
        description="Output file path",
    )
    batch_size: int = Field(default=10, description="Batch processing size")
    max_items_per_node: int = Field(
        default=5,
        description="Maximum number of items per node",
    )


class AutoMCPIndexOutput(BaseModel):
    """Auto MCP Index output"""

    config: Optional[IndexConfig] = Field(
        default=None,
        description="Index configuration",
    )

    def __init__(self, **data: Any) -> None:
        client = data.pop("client", None)
        super().__init__(**data)
        self._client = client

    @property
    def client(self) -> Optional[Any]:
        """Get client object"""
        return getattr(self, "_client", None)


class AutoMCPSearchInput(BaseModel):
    """Auto MCP Search Input"""

    tool_description: str = Field(
        ...,
        description="å¯¹å®Œæˆç”¨æˆ·éœ€æ±‚æ‰€éœ€è¦çš„å·¥å…·çš„åŠŸèƒ½æè¿°ï¼Œä¸€æ¬¡åªèƒ½ä¸ºä¸€ä¸ªéœ€æ±‚æœå¯»å·¥å…·",
    )
    method: str = Field(
        default="semantic_search",
        description=(
            "æœç´¢æ–¹æ³•ï¼Œæ”¯æŒ 'semantic_search', "
            "'tree_search' æˆ– 'hybrid_search'"
        ),
    )
    max_results: int = Field(default=5, description="è¿”å›å·¥å…·æ•°é‡")


class AutoMCPSearchOutput(BaseModel):
    """Auto MCP Search è¾“å‡º"""

    search_results: List[Dict[str, Any]] = Field(
        default=[],
        description="æœç´¢ç»“æœåˆ—è¡¨",
    )


class AutoMCPIndex(Component[AutoMCPIndexInput, AutoMCPIndexOutput]):
    """Auto MCP å·¥å…·ç´¢å¼•æ„å»ºç»„ä»¶"""

    description = "MCPå·¥å…·ç´¢å¼•æ„å»º#æ„å»ºå·¥å…·æœç´¢ç´¢å¼•ï¼Œç”Ÿæˆå·¥å…·æ ‘æ–‡ä»¶å’Œé…ç½®"
    name = "auto_mcp_index"

    @trace(trace_type=TraceType.SEARCH, trace_name="auto_mcp_index")
    async def _arun(
        self,
        args: AutoMCPIndexInput,
        **kwargs: Any,
    ) -> AutoMCPIndexOutput:
        """æ„å»ºå·¥å…·ç´¢å¼•"""
        request_id = kwargs.get("request_id", str(uuid.uuid4()))
        trace_event = kwargs.pop("trace_event", None)

        try:
            # å¯¼å…¥ MCP_Tree
            MCP_Tree = await self._import_mcp_tree()
            if not MCP_Tree:
                return AutoMCPIndexOutput(
                    config=None,
                    client=None,
                )

            # åˆ›å»º MCP Tree å®ä¾‹
            client = MCP_Tree(
                batch_size=args.batch_size,
                max_items_per_node=args.max_items_per_node,
            )

            # åŠ è½½å·¥å…·æ•°æ®
            additional_tools = None
            if hasattr(args, "input_path") and args.input_path:
                try:
                    with open(args.input_path, "r", encoding="utf-8") as f:
                        additional_tools = json.load(f)
                    logger.info(
                        f"ä» {args.input_path} åŠ è½½äº† {len(additional_tools)} ä¸ªå·¥å…·",
                    )
                except Exception as e:
                    logger.warning(f"æ— æ³•åŠ è½½è¾“å…¥æ–‡ä»¶ {args.input_path}: {e}")

            # æ„å»ºå·¥å…·æ ‘
            logger.info("å¼€å§‹æ„å»ºå·¥å…·ç´¢å¼•...")
            await client.build_tree_merge(
                save_path=args.output_path,
                additional_tools=additional_tools,
            )

            # è·å–ç»Ÿè®¡ä¿¡æ¯
            stats = client.get_directory_stats()

            # ç”Ÿæˆé…ç½®æ–‡ä»¶è·¯å¾„
            config_file_path = args.output_path.replace(
                ".json",
                "_config.json",
            )

            # åˆ›å»ºç´¢å¼•é…ç½®
            config = IndexConfig(
                tree_file_path=args.output_path,
                batch_size=args.batch_size,
                max_items_per_node=args.max_items_per_node,
                stats=stats,
            )

            # ä¿å­˜é…ç½®
            with open(config_file_path, "w", encoding="utf-8") as f:
                json.dump(config.model_dump(), f, ensure_ascii=False, indent=2)

            if trace_event:
                trace_event.on_log(
                    "",
                    **{
                        "step_suffix": "results",
                        "payload": {
                            "request_id": request_id,
                            "output_path": args.output_path,
                            "config_path": config_file_path,
                            "stats": stats,
                        },
                    },
                )

            logger.info(f"âœ… å·¥å…·ç´¢å¼•æ„å»ºå®Œæˆ: {args.output_path}")
            logger.info(f"ğŸ“Š ç´¢å¼•ç»Ÿè®¡: {stats}")

            return AutoMCPIndexOutput(
                config=config,
                client=client,
            )

        except Exception as e:
            logger.error(f"æ„å»ºå·¥å…·ç´¢å¼•å¤±è´¥: {e}")
            return AutoMCPIndexOutput(
                config=None,
                client=None,
            )

    async def _import_mcp_tree(self) -> Optional[Any]:
        """Import MCP_Tree"""
        try:
            from agentbricks.mcp_utils.auto_mcp.tool_search.tree_search import (  # noqa E501
                MCP_Tree,
            )

            return MCP_Tree
        except ImportError:

            logger.error("æ— æ³•å¯¼å…¥ MCP_Treeï¼Œè¯·ç¡®ä¿è·¯å¾„æ­£ç¡®")
            return None


class AutoMCPSearch(Component[AutoMCPSearchInput, AutoMCPSearchOutput]):
    """Auto MCP tool searches component"""

    description = "æŸ¥æ‰¾å·¥å…·æœåŠ¡#å¯ä»¥æ ¹æ®ç”¨æˆ·éœ€æ±‚æ·»åŠ å·¥å…·ï¼Œæ·»åŠ åçš„å·¥å…·å¯ä»¥ä½¿ç”¨"
    name = "auto_mcp_search"

    def __init__(
        self,
        mcp_client: Optional[Any] = None,
        config: Optional[IndexConfig] = None,
        **kwargs: Any,
    ) -> None:
        """åˆå§‹åŒ–æœç´¢ç»„ä»¶

        Args:
            mcp_client: é¢„åŠ è½½çš„ MCP å®¢æˆ·ç«¯
            config: ç´¢å¼•é…ç½®å¯¹è±¡
        """
        super().__init__(**kwargs)
        self.mcp_client = mcp_client
        self.config = config

        if not self.mcp_client and self.config:
            # å¦‚æœæœ‰é…ç½®ä½†æ²¡æœ‰å®¢æˆ·ç«¯ï¼Œå°è¯•ä»é…ç½®åŠ è½½å®¢æˆ·ç«¯
            self._load_from_config()

    def _load_from_config(self) -> None:
        """load from config"""
        if not self.config or not self.config.tree_file_path:
            logger.warning("æ— æ•ˆçš„é…ç½®æˆ–ç¼ºå°‘å·¥å…·æ ‘æ–‡ä»¶è·¯å¾„")
            return

        try:
            # åŒæ­¥å¯¼å…¥ MCP_Tree
            MCP_Tree = self._import_mcp_tree_sync()
            if not MCP_Tree:
                logger.warning("æ— æ³•å¯¼å…¥ MCP_Tree")
                return

            self.mcp_client = MCP_Tree.load_tree(self.config.tree_file_path)
            if self.mcp_client:
                logger.info(
                    f"âœ… ä»é…ç½®åŠ è½½ MCP å®¢æˆ·ç«¯æˆåŠŸ: {self.config.tree_file_path}",
                )
            else:
                logger.warning(
                    f"âš ï¸ ä»é…ç½®åŠ è½½ MCP å®¢æˆ·ç«¯å¤±è´¥: {self.config.tree_file_path}",
                )
        except Exception as e:
            logger.error(f"ä»é…ç½®åŠ è½½ MCP å®¢æˆ·ç«¯å¤±è´¥: {e}")

    def _import_mcp_tree_sync(self) -> Optional[Any]:
        """Import MCP_Tree"""
        try:
            # å°è¯•ä»æ–°è·¯å¾„å¯¼å…¥
            from agentbricks.mcp_utils.auto_mcp.tool_search.tree_search import (  # noqa E501
                MCP_Tree,
            )

            return MCP_Tree
        except ImportError:
            return None

    @trace(trace_type=TraceType.SEARCH, trace_name="auto_mcp_search")
    async def _arun(
        self,
        args: AutoMCPSearchInput,
        **kwargs: Any,
    ) -> AutoMCPSearchOutput:
        """execute auto searches"""
        request_id = kwargs.get("request_id", str(uuid.uuid4()))
        trace_event = kwargs.pop("trace_event", None)

        try:
            # æ£€æŸ¥ MCP å®¢æˆ·ç«¯æ˜¯å¦å¯ç”¨
            if not self.mcp_client:
                return AutoMCPSearchOutput(
                    search_results=[],
                )

            # æ‰§è¡Œæœç´¢
            search_results = await self._perform_search(
                args.tool_description,
                args.method,
                args.max_results,
            )

            if trace_event:
                trace_event.on_log(
                    "",
                    **{
                        "step_suffix": "results",
                        "payload": {
                            "request_id": request_id,
                            "tool_description": args.tool_description,
                            "method": args.method,
                            "max_results": args.max_results,
                            "search_results": search_results,
                        },
                    },
                )

            return AutoMCPSearchOutput(
                search_results=search_results,
            )

        except Exception as e:
            logger.error(f"Auto MCP æœç´¢å¤±è´¥: {e}")
            return AutoMCPSearchOutput(
                search_results=[],
            )

    async def _perform_search(
        self,
        query: str,
        method: str,
        max_results: int,
    ) -> List[Dict[str, Any]]:

        try:
            logger.info(f"ğŸ” æœç´¢å·¥å…·: {query}, æ–¹æ³•: {method}")

            # æ£€æŸ¥å®¢æˆ·ç«¯å’Œæœç´¢ç®¡ç†å™¨æ˜¯å¦å­˜åœ¨
            if (
                not self.mcp_client
                or not hasattr(self.mcp_client, "searches")
                or not self.mcp_client.search
            ):
                logger.warning("MCP å®¢æˆ·ç«¯æˆ–æœç´¢ç®¡ç†å™¨ä¸å¯ç”¨")
                return []

            # æ ¹æ®æ–¹æ³•é€‰æ‹©æœç´¢å‡½æ•°
            if method == "semantic_search":
                # ä½¿ç”¨è¯­ä¹‰æœç´¢
                if hasattr(self.mcp_client.search, "tool_similarity_search"):
                    search_results = (
                        await self.mcp_client.search.tool_similarity_search(
                            query,
                            top_k=max_results,
                        )
                    )
                else:
                    search_results = []
            elif method == "tree_search":
                # ä½¿ç”¨æ ‘æœç´¢ - æ ¹æ® tree_search.py ä¸­çš„æœç´¢æ–¹æ³•è°ƒæ•´
                if hasattr(self.mcp_client.search, "multi_tool_search"):
                    search_results = (
                        await self.mcp_client.search.multi_tool_search(
                            query,
                            max_results=max_results,
                        )
                    )
                else:
                    search_results = []
            elif method == "hybrid_search":
                # ä½¿ç”¨æ··åˆæœç´¢
                if hasattr(self.mcp_client.search, "hybrid_multi_tool_search"):
                    search_results = (
                        await self.mcp_client.search.hybrid_multi_tool_search(
                            query,
                            max_results=max_results,
                        )
                    )
                else:
                    search_results = []
            else:
                logger.warning(f"æœªçŸ¥æœç´¢æ–¹æ³•: {method}ï¼Œä½¿ç”¨é»˜è®¤æ··åˆæœç´¢")
                if hasattr(self.mcp_client.search, "hybrid_multi_tool_search"):
                    search_results = (
                        await self.mcp_client.search.hybrid_multi_tool_search(
                            query,
                            max_results=max_results,
                        )
                    )
                else:
                    search_results = []

            # ç¡®ä¿è¿”å›æ­£ç¡®çš„æ•°æ®æ ¼å¼
            if search_results is None:
                search_results = []
            elif not isinstance(search_results, list):
                # å¦‚æœæœç´¢ç»“æœä¸æ˜¯åˆ—è¡¨ï¼Œå°è¯•è½¬æ¢æˆ–è¿”å›ç©ºåˆ—è¡¨
                logger.warning(
                    f"æœç´¢ç»“æœä¸æ˜¯æœŸæœ›çš„åˆ—è¡¨æ ¼å¼: {type(search_results)}",
                )
                search_results = []

            logger.info(f"âœ… æ‰¾åˆ° {len(search_results)} ä¸ªå·¥å…·")
            return search_results

        except Exception as e:
            logger.error(f"æœç´¢å¤±è´¥: {e}")
            return []
